<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo博客设置以及Next主题美化]]></title>
    <url>%2FHexo%2FHexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[之前的一篇文章写了用Hexo和GitHu搭建博客，现在就来对博客主题做一些个性化的修改。 安装Next主题切换到博客的目录，使用Git Bash运行下载主题：1git clone https://github.com/iissnan/hexo-theme-next themes/next 然后打开根目录下的_config.yml，注意这个是整个博客站点的配置文件，而主题目录下也有一个_config.yml，这是主题的配置文件。在站点配置文件找到theme改为next：1theme: next 这样就启用了主题，可以运行hexo s查看效果了。 博客设置这里先对博客基本信息做一些设置，注意了，设置时冒号后面都要有一个空格，这是yml文件的格式 设置语言首先先设置博客站点的语言，这个是在站点配置文件，也就是根目录下的_config.yml设置的，找到language设置成中文：1language: zh-Hans 基本信息在站点配置文件的开头，填上自己博客的相应信息：123456title: # 标题subtitle: # 副标题description: # 站点描述author: # 作者language: zh-Hanstimezone: 主题设置Next已经自带了很多功能和集成了一些第三方服务，通过主题目录下的_config.yml就能对主题做一些设定及个性化。 设置主题的SchemeNext自带了几种外观，在主题目录的_config.yml里找到scheme，我比较喜欢Mist，把前面的注释符#去掉即可：1234#scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 菜单设置我们可以看到首页有还有归档等菜单，这些在主题配置文件里设置，找到menu，把需要的菜单取消注释，我这里保留了categories分类，tags标签，archives归档，about关于，||后面的表示图标，使用Font Awesome图标名字。我就不作修改了：123456789menu: home: / || home categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 另外，也可以自己添加菜单，但我暂时没有这个需要。 创建页面设置完菜单但是没有页面的话点击菜单就会报错了。创建刚才建了菜单的页面执行以下命令：123hexo new page tagshexo new page categorieshexo new page about 然后在source目录下就会生成对应的文件夹，每个文件夹里都有一个index.md，打开将页面的type设置为相应的内容。12345title: 标签date: type: &quot;tags&quot; # 或者 &quot;categories&quot;/&quot;about&quot;comments: false--- comments是关闭这个页面的评论功能用的，评论后面会提到。 文章显示设置默认首页的文章会显示全文，在主题配置文件设置auto_excerpt为true再设置长度就会只显示你设置的字数了。123auto_excerpt: enable: true length: 100 但是，官方是不推荐这种做法的，我这里用的方法是发表的文章的开头加上description，这样，文章就会显示这个摘要：1234567891011title: # 文章标题author: # 作者tags: - Hexo - Nextcategories: - Hexo - Nextdescription: # 描述，首页文章显示的摘要date: --- 这里的tags和categories就是给文章加上标签和分类，两者的区别就是categories是有层级的，像上面那样分类里Next就是Hexo的子类，Hexo是不支持指定多个同级分类的。 使用RSS先在博客目录下执行以下命令安装插件：1npm install --save hexo-generator-feed 然后在主题配置文件里找到rss修改：1rss: /atom.xml 之后在右边的侧边栏就能看到RSS按钮了 设置头像在source目录下新建一个images目录，放一张名为avatar.png的头像，修改主题配置文件的avatar字段：1avatar: /images/avatar.png 设置博客favicon图标在images目录下放置图标，我这里放了两种大小的ico图标，然后在主题配置文件找到favicon并修改：1234567favicon: small: /images/favicon-16x16.ico medium: /images/favicon-32x32.ico #apple_touch_icon: /images/apple-touch-icon-next.png #safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 侧边栏社交链接在主题配置文件找到social把需要的取消注释，然后填好你的链接就可以了，||后面的是图标名称，和菜单的一样，也是使用Font Awesome图标名字。1234567891011social: GitHub: https://github.com/JianFengY || github GMail: mailto:yjianfengxy@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter Facebook: https://www.facebook.com/jf.young.1 || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 你也可以自行添加其他社交方式，按照格式添加即可。 设置背景动画同样是主题配置文件，我这里用的是canvas_nest：1234567891011# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false 修改文章底部的#号标签打开/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将#换成Font Awesome图标:1&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 评论系统我使用的是来必力 点击这里 注册账号，然后复制下面的data-uid： 在主题配置文件找到livere_uid：123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: # 粘贴你的uid 这样，除了设置了comments: false的页面，其他都会有评论系统了。 网站底部加访问量这个我是通过修改\themes\next\layout\_partials\footer.swig文件实现的:12345678910&lt;div class=&quot;powered-by&quot;&gt; &lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; &lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; &lt;/span&gt;&lt;/div&gt; 统计功能先在博客目录下安装插件：1npm install hexo-wordcount --save 然后在主题配置文件，找到post_wordcount，修改你想要的统计功能，有字数统计，阅读时长等：12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true 搜索服务Local Search先安装hexo-generator-searchdb，博客目录执行：1npm install hexo-generator-searchdb --save 然后在站点配置文件，注意不是主题配置，添加以下代码：12345search: path: search.xml field: post format: html limit: 10000 然后主题配置文件找到local_search改为true，然后从上面提供的样式选一个填入pace_theme中就可以了：123# Local searchlocal_search: enable: true 然后菜单就会出现搜索了。 顶部加载条修改主题配置文件，找到pace改为true，并从上面提供的样式中选择一种填入pace_theme中就可以了：12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal 右上角加fork me on github点击 这里 或者 这里 挑选你喜欢的样式，修改成你的GitHub链接，复制到themes/next/layout/_layout.swig文件中的以下位置：123&lt;div class=&quot;&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125;&quot;&gt; &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; &lt;a href=&quot;https://github.com/JianFengY&quot; ......&lt;/a&gt; 浏览文章时显示浏览进度主题设置文件查找scrollpercent修改为true：12# Scroll percent label in b2t button.scrollpercent: true]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫Scrapy入门篇]]></title>
    <url>%2FPython%2F%E7%88%AC%E8%99%AB%2FPython%E7%88%AC%E8%99%ABScrapy%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言因为Python简单灵活的特点，一直是写爬虫的热门语言，我之前也在公众号上分享过几篇简单的爬虫例子和教程。 Scrapy是一款简单高效的Python网络爬虫框架，使用框架，我们就可以只关注数据的提取而不用去自己造轮子了。其实，对于这个框架，我也是个新手…这里，就用我们学校的图书馆系统做个简单的入门项目了。 安装先说一下我的Python是3.6版本的，电脑是win10。 Scrapy也可以直接用使用pip命令安装：1pip install scrapy 因为Scrapy依赖了其他一些包，所以会额外安装一些库，如lxml、Twisted和pyOpenSSL等，这在文档也有提到。我在安装这些库时有遇到一个问题，报了下面这个错误：1Command &quot;&quot;d:\program files\python3.6.1\python.exe&quot; -u -c &quot;import setuptools, tokenize;__file__=&apos;C:\\Users\\ASUS\\AppData\\Local\\Temp\\pip-build-qkm97m8f\\Twisted\\setup.py&apos;;f=getattr(tokenize, &apos;open&apos;, open)(__file__);code=f.read().replace(&apos;\r\n&apos;, &apos;\n&apos;);f.close();exec(compile(code, __file__, &apos;exec&apos;))&quot; install --record C:\Users\ASUS\AppData\Local\Temp\pip-e4cf8gml-record\install-record.txt --single-version-externally-managed --compile&quot; failed with error code 1 in C:\Users\ASUS\AppData\Local\Temp\pip-build-qkm97m8f\Twisted\ 可以看到是安装Twisted出的问题，解决方法是在 这里 下载对应版本的whl包，我的是Twisted-17.9.0-cp36-cp36m-win32.whl，cp后面是Python版本，win32表示位数，我的Python是32位的。 然后切换到下载目录运行以下命令：1pip install Twisted-17.9.0-cp36-cp36m-win32.whl 然后再安装Scrapy就可以了。你会看到：1Successfully installed PyDispatcher-2.0.5 asn1crypto-0.24.0 cffi-1.11.4 cryptography-2.1.4 cssselect-1.0.3 parsel-1.4.0 pyOpenSSL-17.5.0 pyasn1-0.4.2 pyasn1-modules-0.2.1 pycparser-2.18 queuelib-1.4.2 scrapy-1.5.0 service-identity-17.0.0 创建项目切换到你想放这个项目的目录，执行scrapy startproject projectname创建一个项目，如：1scrapy startproject scrapy_test 生成的项目结构是这样的：12345678910scrapy_test/ scrapy.cfg # deploy configuration file scrapy_test/ # project&apos;s Python module, you&apos;ll import your code from here __init__.py items.py # project items definition file middlewares.py # project middlewares file pipelines.py # project pipelines file settings.py # project settings file spiders/ # a directory where you&apos;ll later put your spiders __init__.py spiders目录用于放置我们的爬虫，items.py用于定义我们要获取的数据，pipelines.py定义存储，settings.py顾名思义就是配置文件了。 编写代码 第一步我们先定义要存储什么字段，这里就定义书名、作者和索引号吧，编写items.py：1234567891011import scrapyclass BooksItem(scrapy.Item): &apos;&apos;&apos;定义要存储的字段&apos;&apos;&apos; # 书名 name = scrapy.Field() # 作者 author = scrapy.Field() # 索引号 call_number = scrapy.Field() 接下来我们在spiders目录下编写爬虫文件，我这里新建一个books_spider.py文件，代码如下：1234567891011121314151617181920212223import scrapyfrom scrapy_test.items import BooksItemclass BooksSpider(scrapy.Spider): &apos;&apos;&apos;图书爬虫类&apos;&apos;&apos; # 这个name不能重复 name = &apos;books&apos; # allowed_domains = [&apos;202.116.174.108:8080&apos;] start_urls = [&quot;http://202.116.174.108:8080/top/top_lend.php?cls_no=ALL&quot;] def parse(self, response): &apos;&apos;&apos;处理下载的response的默认方法&apos;&apos;&apos; books = [] for item in response.xpath(&apos;//tr&apos;)[1:]: book = BooksItem() book_name = item.xpath(&apos;td[2]/a/text()&apos;).extract() book_author = item.xpath(&apos;td[3]/text()&apos;).extract() book_call_number = item.xpath(&apos;td[5]/text()&apos;).extract() book[&apos;name&apos;] = book_name[0] book[&apos;author&apos;] = book_author[0] book[&apos;call_number&apos;] = book_call_number[0] books.append(book) return books 这个类继承scrapy.Spider，需要指定name，它是运行爬虫用的，start_urls是要爬取的url列表，parse函数接收获取到的response解析用的是scrapy自带的xpath,这个网页的结构很简单，所以就不多解释了。总之，就是遍历每一本书的信息，然后存在books中。这些信息在之前的item中已经定义了。代码的编写到这里就结束了，接下来就可以运行了。 运行代码要运行代码，切换到项目的目录里，执行下面的命令，其中books就是上面的name，books.json就是生成的json文件：1scrapy crawl books -o books.json -t json 开始运行时，出现了一个问题，就是没报错，但没有结果，输出一片空白，然后发现下面的提示：1DEBUG: Forbidden by robots.txt 这是因为要获取的页面在robots中被禁止了，所以Scrapy自动忽略了，只需修改settings.py将：ROBOTSTXT_OBEY改为False就行了。 后来又遇到了乱码的问题，输出全是\uxxx这种字符，只要在settings.py加上FEED_EXPORT_ENCODING = &#39;utf-8&#39;就可以。 没报错执行完上面的命令之后就会在根目录生成一个books.json文件，打开，就会看到保存下来的json格式图书信息：123456789101112131415161718192021222324[ &#123; &quot;name&quot;: &quot;暗恋·橘生淮南&quot;, &quot;author&quot;: &quot;八月长安[著]&quot;, &quot;call_number&quot;: &quot;I247.57/5494&quot; &#125;, &#123; &quot;name&quot;: &quot;Time series and panel data econometrics / First edition.&quot;, &quot;author&quot;: &quot;M. Hashem Pesaran.&quot;, &quot;call_number&quot;: &quot;F224.0/EN4&quot; &#125;, &#123; &quot;name&quot;: &quot;杀死一只知更鸟.第2版&quot;, &quot;author&quot;: &quot;(美国) 哈珀·李著&quot;, &quot;call_number&quot;: &quot;I712.45/1231=2&quot; &#125;, ... ... &#123; &quot;name&quot;: &quot;众筹:互联网金融的下一个风口&quot;, &quot;author&quot;: &quot;陈晓暾, 白帆, 陈英编著&quot;, &quot;call_number&quot;: &quot;F830.45/77&quot; &#125;] 我们的Scrapy入门项目就完成了！]]></content>
      <categories>
        <category>Python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo搭建个人博客]]></title>
    <url>%2FHexo%2FHexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[其实网上已经有很多这样的教程了，我这里只是把自己一步步搭建的过程做一些记录而已。闲话不多说，马上开始。 准备环境 Git，先 点击这里 下载Git安装，安装过程我就不作说明了 Node.js，点击这里 下载安装，安装也很简单方便，这里也不作说明，记得安装上npm就好 GitHub账号当然不能少，这里就默认你已经有账号了…没有的 点击这里 去注册吧 Hexo安装与搭建首先，新建一个文件夹，你的博客就要放在这里，我这里是E:\hexo，然后，在这个文件夹里右键Git Bash Here，因为要使用到这个，所以就不用cmd命令行直接用这个了。执行以下命令安装Hexo：1npm install -g hexo-cli 再执行以下命令，生成建立网站所需要的所有文件并安装依赖包：12hexo initnpm install 然后，我们在根目录下的_config.yml文件，填上自己博客的相应信息，注意，冒号后面都要有一个空格，这是yml文件的格式：123456title: # 标题subtitle: # 副标题description: # 站点描述author: # 作者language: zh-Hanstimezone: 然后，以下命令生成静态页面并开启本地服务器12hexo generatehexo server 现在，浏览器输入http://localhost:4000就能查看你的博客了，当然，只是本地，接下来，就是放到GitHub上让别人能访问了。 部署到GitHub创建仓库首先New Repository，名称是username.github.io，username要与账号对应，比如我的就是JianFengY.github.io，所以，我的GitHub账号本来应该全部小写字母的，这样会比较协调… 生成SSH密钥执行以下命令，不出意外应该是一直回车就好。1ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 然后，在C:\Users\ASUS\.ssh目录会有两个文件id_rsa和id_rsa.pub,打开id_rsa.pub，复制里面的所有内容到 SSH keys这里 的Key，Title随便填，然后Add SSH key就可以了 部署首先，在根目录下的_config.yml文件，找到deploy，填上相应信息，repo就是上面创建的仓库地址：1234deploy: type: git repo: https://github.com/username/username.github.io.git branch: master 安装hexo-deployer-git部署发布工具:1npm install hexo-deployer-git --save 然后就可以使用以下命令发布你的博客了，第一次发布会让你输入Github 的邮箱和密码：1hexo generate &amp;&amp; hexo deploy 这里贴一下Hexo常用命令：1234567hexo init # 初始化目录hexo server 或 hexo s # 本地服务器预览hexo new &quot;postName&quot; 或 hexo n &quot;postName&quot; # 新建文章hexo new page &quot;pageName&quot; 或 hexo n &quot;pageName&quot; # 新建页面hexo generate 或 hexo g # 生成网页在 public 目录有整个网站的文件hexo deploy 或 hexo d # 部署.deploy目录hexo clean # 清除缓存 完成现在，浏览器输入https://username.github.io/我的就是https://jianfengy.github.io/就能查看你的博客了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu配置JDK、MySQL和Tomcat遇到的一些坑]]></title>
    <url>%2FUbuntu%2FUbuntu%E9%85%8D%E7%BD%AEJDK%E3%80%81MySQL%E5%92%8CTomcat%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[之前买了阿里云的Ubuntu服务器，安装JDK、MySQL和Tomcat的时候遇到了一些问题，折腾了挺长时间，这里是一些记录。 安装配置JDKwindows上下载的jdk-8u161-linux-i586.tar.gz用xshell执行rz命令上传到阿里云的ubuntu，然后执行mkdir /usr/java建一个文件夹，再执行tar zxvf jdk-8u161-linux-i586.tar.gz -C /usr/java解压到java目录下，之后执行vim ~/.bashrc在文件尾添加以下内容设置环境变量：1234export JAVA_HOME=/usr/java/jdk1.8.0_151export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:&#123;JAVA_HOME&#125;/lib:&#123;JRE_HOME&#125;/libexport PATH=&#123;JAVA_HOME&#125;/bin:PATH 这里遇到了报错-bash: java/ jdk1.8.0_131/bin/java: cannot execute binary file，是因为我下载的JDK是64位的，而ubuntu是32位的…使用getconf LONG_BIT命令可以查看linux位数。 安装配置Mysql安装时有遇到Err http://mirrors.aliyun.com/ubuntu 404 Not Found，执行sudo apt-get update就可以了。 网上学到的一个技巧：如果忘记了MySQL账户的密码，文件/etc/mysql/debian.cnf里有个MySQL用户debian-sys-maint。可以mysql -u debian-sys-maint -p使用文件提供的密码登录MySQL修改root的密码。 修改MySQL密码时因为设置的密码过于简单会报错Your password does not satisfy the current policy requirements，处理如下：123456789101112mysql&gt; update mysql.user set authentication_string=password(&apos;123456&apos;) where user=&apos;root&apos; and Host =&apos;localhost&apos;;ERROR 1819 (HY000): Your password does not satisfy the current policy requirementsmysql&gt; set global validate_password_policy=0;Query OK, 0 rows affected (0.00 sec)mysql&gt; set global validate_password_length=4;Query OK, 0 rows affected (0.00 sec)mysql&gt; update mysql.user set authentication_string=password(&apos;123456&apos;) where user=&apos;root&apos; and Host =&apos;localhost&apos;;Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1 安装配置tomcat安装运行之后不能使用外网访问，执行ufw allow 8080允许外网可以访问8080端口然后配置阿里云安全组，找到自己的实例，点击更多-安全组配置-配置规则-添加安全组规则配置端口范围8080/8080，授权对象0.0.0.0/0之后就可以了。]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>JDK</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql学习笔记]]></title>
    <url>%2FMySQL%2FMySql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这是我之前在慕课网学习 与MySQL的零距离接触 时的笔记，整理了一下发上来。 修改MySQL提示符 参数 描述 \p 完整的日期 \d 当前数据库 \h 服务器名称 \u 当前用户 各个参数可以结合使用。如prompt \u@\h \d&gt; 连接客户端时指定 1mysql -uroot -p123456 --prompt \h 连接上客户端后 1PROMPT &quot;提示符&quot; MySQL常用命令 显示当前服务器版本SELECT VERSION(); 显示当前日期时间SELECT NOW(); 显示当前用户SELECT USER(); 可用SHOW WARNINGS;查看警告信息 MySQL语句规范 关键字与函数名称全部大写 数据库名称、表名称、字段名称全部小写 SQL语句必须以分号结尾 操作数据库 “{}”表示必选项， “|”表示或， “[]”表示可选项 创建数据库1CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset_name; 例如：1CREATE DATABASE IF NOT EXISTS db_name CHARACTER SET utf8; 查看当前服务器下数据表列表 1SHOW &#123;DATABASES | SCHEMAS&#125; [LIKE &apos;pattern&apos; | WHERE expr]; 修改数据库 1ALTER &#123;DATABASE | SCHEMA&#125; [db_name] [DEFAULT] CHARACTER SET [=] charset_name; 例如：1ALTER DATABASE db_name CHARACTER SET = gbk; 删除数据库1DROP &#123;DATABASE | SCHEMA&#125; [IF EXISTS] db_name; 数据类型 整型 数据类型 字节 TINYINT 1 SMALLINT 2 MEDIUMINT 3 INT 4 BIGINT 8 浮点型 FLOAT[(M,D)] DOUBLE[(M,D)] M是数字总位数，D是小数点后面的位数。 日期时间型 列类型 存储需求 YEAR 1 TIME 3 DATE 3 DATETIME 8 TIMESTAMP 4 字符型 列类型 存储需求 CHAR(M) M个字节，0&lt;=M&lt;=255 VARCHAR(M) L+1个字节，其中L&lt;=M且0&lt;=M&lt;=65535 TINYTEXT L+1个字节，其中L&lt;2^8 TEXT L+2个字节，其中L&lt;2^16 MEDIUMTEXT L+3个字节，其中L&lt;2^24 LONGTEXT L+4个字节，其中L&lt;2^32 ENUM(‘value1’,’value2’,…) 1或2个字节，取决于枚举值的个数(最多65536个值) SET(‘value1’,’value2’,…) 1、2、3、4或8个字节，取决于set成员数目(最多64个成员) 数据表创建数据表1234CREATE TABLE [IF NOT EXISTS] table_name (column_name data_type,...); 例如：12345CREATE TABLE table_name(username VARCHAR(20),age TINYINT UNSIGNED,salary FLOAT(8,2) UNSIGNED); UNSIGNED表示无符号位，即始终为正数。使用SHOW CREATE TABLE table_name;可以查看建表语句 查看数据表1SHOW TABLES [FROM db_name] [LIKE &apos;pattern&apos; | WHERE expr]; 查看数据表结构1SHOW COLUMNS FROM table_name; 或：1DESC table_name; 插入记录1INSERT [INTO] table_name[(col_name,...)] VALUES(val,...); 查找记录1SELECT expr,... FROM table_name; 空值与非空 NULL，字段值可以为空(可以不写，默认可以为空) NOT NULL，字段值禁止为空 自动编号AUTO_INCREMENT ,必须与主键组合使用，默认情况下，起始值为1，每次增量为1，不需要赋值 主键约束PRIMARY KEY ,每张表只能存在一个主键,用于保证记录的唯一性(不能有重复值)，主键自动为NOT NULL 唯一约束UNIQUE KEY ,可以保证记录唯一性，唯一约束的字段可以为空(NULL)，每张表可以存在多个唯一约束 默认约束DEFAULT ,默认值，插入记录时，如果没有明确为字段复制，则自动赋予默认值 外键约束作用：保证数据的一致性、完整性；实现一对一或一对多关系 要求： 父表（子表所参照的表）和子表（具有外键列的表）必须使用相同的存储引擎（InnoDB），且禁止使用临时表 外键列（有FOREIGN KEY关键字的列）和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度可以不同。否则会报错(errorno：150) 外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL会自动创建索引（主键都会自动创建索引）.以网格形式查看索引：SHOW INDEXES FROM db_name\G; 编辑数据表默认存储引擎在安装MySQL的磁盘的Server 5.7\my.ini```文件里，修改为```default-storage-engine12例： CREATE TABLE provinces(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,pname VARCHAR(20) NOT NULL);1234567```CREATE TABLE users(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,username VARCHAR(20) NOT NULL,pid SMALLINT UNSIGNED,FOREIGN KEY (pid) REFERENCES provinces (id)); 外键约束的参照操作 CASCADE：从父表删除或更新且自动删除或更新子表中匹配的行 SET NULL：从父表删除或更新行，并设置子表中的外键列为NULL。如果适用此项，必须保证兹表列没有制定NOT NULL RESTRICT：拒绝对父表的删除或更新操作 NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同 例：123456CREATE TABLE users1(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,username VARCHAR(10) NOT NULL,pid SMALLINT UNSIGNED,FOREIGN KEY (pid) REFERENCES provinces (id) ON DELETE CASCADE); 表示级联删除，此时删除provinces表中的记录，user1中相关的记录也会被删除，级联更新ON UPDATE CASCADE同理 表级约束与列级约束 对一个数据列建立的约束，称为列级约束。既可以在列定义时声明，也可以在列定义后声明（NOT NULL和DEFAULT约束只有列级约束，其他几种约束则可以有表级也可以有列级约束） 对多个数据列建立的约束，称为表级约束。只能在列定义后声明 修改数据表添加单列1ALTER TABLE table_name ADD [COLUMN] column_name column_definition [FIRST | AFTER column_name; 其中，FIRST指把新列放在最前面，AFTER指把新列放在指定列，不加此参数默认添加到所有列最后面 添加多列1ALTER TABLE table_name ADD [COLUMN] (column_name column_definition, ...); 添加多列时，要加小括号，且不能制定添加的位置 删除列1ALTER TABLE table_name DROP [COLUMN] column_name; 可以同时操作几个语句，用逗号隔开,如：1ALTER TABLE table_name DROP [COLUMN] column_name,DROP [COLUMN] column_name,ADDADD [COLUMN] column_name column_definition; 添加主键约束1ALTER TABLE table_name ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name, ...); 例：1ALTER TABLE users2 ADD CONSTRAINT PK_users2_id PRIMARY KEY (id); 删除主键约束1ALTER TABLE table_name DROP PRIMARY KEY; 添加唯一约束1ALTER TABLE table_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX | KEY] [index_name] [index_type] (index_col_name, ...); 例：1ALTER TABLE users2 ADD UNIQUE (username); 删除唯一约束要删除唯一约束需要先知道约束的名字：1SHOW INDEXES FROM table_name\G; 1ALTER TABLE table_name DROP &#123;INDEX | KEY&#125; index_name; 添加外键约束1ALTER TABLE table_name ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name, ...) reference_difinition; 例：1ALTER TABLE users2 ADD FOREIGN KEY (pid) REFERENCES provinces (id); 删除外键约束删除外键约束也要先知道约束的名字：1SHOW CREATE TABLE table_name; 1ALTER TABLE table_name DROP FOREIGN KEY fk_symbol; 添加/删除默认约束1ALTER TABLE table_name ALTER [COLUMN] col_name &#123;SET DEFAULT literal | DROP DEFAULT&#125;; 例：12ALTER TABLE users2 ALTER age SET DEFAULT 15;ALTER TABLE users2 ALTER age DROP DEFAULT; 修改列定义1ALTER TABLE table_name MODIFY [COLUMN] col_name column_difinition [FIRST | AFTER col_name]; 例：1ALTER TABLE users2 MODIFY id SMALLINT UNSIGNED NOT NULL FIRST; 注意： 由于存储范围不同，数据类型由大类型改为小类型时可能会导致数据丢失 修改列名称1ALTER TABLE table_name CHANGE [COLUMN] old_col_name new_col_name column_difinition [FIRST | AFTER col_name]; 使用CHANGE语句既可以修改列名称也可以修改列定义 修改数据表名1ALTER TABLE table_name RENAME [TO | AS] new_table_name; 或：1RENAME TABLE table_name TO new_table_name [, table_name2 TO new_table_name2] ... ; RENAME TABLE这个语句可以修改多个数据表的名字 例：12ALTER TABLE users2 RENAME users3;RENAME TABLE users3 TO users2,users1 TO users4; 尽量少使用修改数据列或数据表名的命令，因为在创建了索引或使用了视图或存储过程后，表名和列名被引用的情况下，更名可能会导致视图等无法正常工作 操作记录插入记录第一种方式：1INSERT [INTO] table_name [(col_name, ...)] &#123;VALUES | VALUE&#125; (&#123;expr | DEFAULE&#125;,...),(...),...; 插入的值可以写数学表达式也可以写一些函数如md5(&#39;123&#39;)，也可以一次插入多条记录插入时把AUTO_INCREMENT的字段赋值为NULL或DEFAULT都会自动递增 第二种方式：1INSERT [INTO] table_name SET col_name=&#123;expr | DEFAULT&#125;,...; 与第一种方式的区别在于，此方法可以使用子查询(SubQuery)，而且一次只能插入一条记录 第三种方式： 1INSERT [INTO] table_name [(col_name,...)] SELECT ...; 此方法可以将SELECT查询结果插入到指定数据表，见下文子查询 更新记录（单表更新）1UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1=&#123;expr1 | DEFAULT&#125; [, col_name2=&#123;expr2 | DEFAULT&#125;] ... [WHERE where_condition]; 可以一次更新多条记录，不加WHERE会更新所有记录 例：1UPDATE users SET age = age + 10 WHERE id % 2 = 0; 删除记录（单表删除）1DELETE FROM table_name [WHERE where_condition]; 查询记录123456789SELECT select_expr [, select_expr ...][ FROM table_references [WHERE where_condition] [GROUP BY &#123;col_name | position&#125; [ASC | DESC],...] [HAVING where_condition] [ORDER BY &#123;col_name | expr |position&#125; [ASC | DESC],...] [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;]]; 查询表达式select_expr： 每一个表达式表示想要的一列，必须有至少一个 多个列之间以英文逗号分隔 星号(*)表示所有列。table_name.*可以表示命名表的所有列 查询表达式可以使用[AS] alias_name为其赋予别名 别名可用于GROUP BY, ORDER BY或HAVING子句 条件表达式对记录进行过滤，如果没有指定WHERE子句，则显示所有记录。在WHERE表达式中，可以使用MySQL支持的函数或运算符 查询结果分组[GROUP BY {col_name | position} [ASC | DESC],...]，ASC为升序DESC为降序，默认是升序 分组条件[HAVING where_condition],条件中若使用字段，要保证字段出现在select_expr中，或者使用聚合函数，如count()等 对查询结果进行排序[ORDER BY {col_name | expr |position} [ASC | DESC],...]，position指字段在select_expr中出现的位置，推荐尽量直接指定字段名 限制查询结果返回的数量1[LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;] 例：SELECT * FROM users LIMIT 3,2;表示从第四条开始（编号从0开始，且顺序是查询结果的顺序，受ORDER BY等影响），返回共两条数据 子查询子查询(SubQuery) 是指出现在其他SQL语句内的SELECT子句如：1SELECT * FROM t1 WHERE col1 = (SELECT col2 FROM t2); 其中 SELECT * FROM t1 称为 Outer Query[外查询](或者Outer Statement) , SELECT col2 FROM t2 称为 SubQuery[子查询]。 子查询是嵌套在外查询内部，也有可能在子查询内部再嵌套子查询。而且子查询必须出现在圆括号之间 子查询可以包含多个关键字或条件，如DISTINCT, GROUP BY, ORDER BY, LIMIT, 函数等 子查询的外层查询可以是SELECT, INSERT, UPDATE, SET或DO 子查询的返回值可以是标量、一行、一列或子查询使用比较运算符的子查询比较运算符：=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, !=, &lt;=&gt; 语法结构：operand comparison_operator [ANY | SOME | ALL] subquery 例：1SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &gt; (SELECT ROUND(AVG(goods_price),2) AS avg_price FROM tdb_goods) ORDER BY goods_price DESC; AVG(), MAX(), MIN(), COUNT(), SUM()等为聚合函数，聚合函数只有一个返回值使用比较运算符时，如果子查询返回值多于一行记录可能会报错，这时需要用ANY, SOME或ALL修饰： ANY SOME ALL &gt;, &gt;= 最小值 最小值 最大值 &lt;, &lt;= 最大值 最大值 最小值 = 任意值 任意值 &lt;&gt;, != 任意值 例：1SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price = ANY(SELECT goods_price FROM tdb_goods WHERE goods_cate = &apos;超级本&apos;) ORDER BY goods_price DESC; 使用[NOT] IN 的子查询语法结构：operand comparison_operator [NOT] IN (subquery) 注意： =ANY和=SOME运算符与IN等效；!=ALL或&lt;&gt;ALL运算符与NOT IN等效 使用[NOT] EXISTS的子查询如果子查询返回任何行，EXISTS将返回TRUE，否则返回FALSE 使用INSERT...SELECT插入记录例：1INSERT tdb_goods_cates (cate_name) SELECT goods_cate FROM tdb_goods GROUP BY goods_cate; 多表更新1UPDATE table_references SET col_name1=&#123;expr1 |DEFAULT&#125; [, col_name2=&#123;expr2 | DEFAULT&#125;]... [WHERE where_condition]; 多表更新时可能会出现字段名混淆，这时候一般会使用AS给表起别名，如： 1UPDATE tdb_goods AS g INNER JOIN tdb_goods_brands AS b ON g.brand_name = b.brand_name SET g.brand_name = b.brand_id; 创建表同时插入记录CREATE...SELECT1CREATE TABLE [IF NOT EXISTS] table_name [&#123;create_definition,...)] select_statement; 例：1234CREATE TABLE tdb_goods_brands (brand_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,brand_name VARCHAR(40) NOT NULL) SELECT brand_name FROM tdb_goods GROUP BY brand_name; 连接MySQL在SELECT语句、多表更新、多表删除语句中支持JOIN操作 连接类型： INNER JOIN内连接。MySQL中，JOIN, CROSS JOIN和INNER JOIN是等价的 LEFT [OUTER] JOIN左外连接 RIGHT [OUTER] JOIN右外连接 连接条件ON或WHERE： 通常使用ON关键字来设定连接条件 使用WHERE关键字进行结果集记录的过滤 语法结构：table_reference {[INNER | CROSS] JOIN | {LEFT | RIGHT} [OUTER] JOIN} table_reference ON conditional_expr 数据表参照table_reference1table_name [[AS] alias] | table_subquery [AS] alias 数据表可以使用table_name AS alias_name或table_name alias_name赋予别名 table_subquery可以作为子查询使用在FROM子句中，这样的子查询必须为其赋予别名 内连接显示左表及右表符合连接条件的记录，即两表的公共部分 左外连接显示左表的全部记录及右表符合连接条件的记录 右外连接显示右表的全部记录及左表符合连接条件的记录 多表连接通过内连接实现查询所有商品的详细信息：123SELECT goods_id,goods_name,cate_name,brand_name,goods_price FROM tdb_goods AS gINNER JOIN tdb_goods_cates AS c ON g.cate_id = c.cate_idINNER JOIN tdb_goods_brands AS b ON g.brand_id = b.brand_id\G; 通过左外连接实现查询所有商品的详细信息：123SELECT goods_id,goods_name,cate_name,brand_name,goods_price FROM tdb_goods AS gLEFT JOIN tdb_goods_cates AS c ON g.cate_id = c.cate_idLEFT JOIN tdb_goods_brands AS b ON g.brand_id = b.brand_id\G; 通过右外连接实现查询所有商品的详细信息：123SELECT goods_id,goods_name,cate_name,brand_name,goods_price FROM tdb_goods AS gRIGHT JOIN tdb_goods_cates AS c ON g.cate_id = c.cate_idRIGHT JOIN tdb_goods_brands AS b ON g.brand_id = b.brand_id\G; 一些说明 对于左外连接A LEFT JOIN B join_condition（右外连接类似）： 数据表B的结果集依赖数据表A 数据表A的结果集根据左连接条件以来所有数据表（B表除外） 左外连接条件决定如何检索数据表B（在没有制定WHERE条件的情况下） 如果数据表A的某条记录符合WHERE条件，但是数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外B行 如果使用内连接查找的记录在连接数据表中不存在，并且在WHERE子句中尝试以下操作：col_name IS NULL时，如果col_name被定义为NOT NULL，MySQL将在找到符合连接条件的记录后停止搜索更多的行 无限分类的数据表设计例：12345CREATE TABLE tdb_goods_types(type_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,type_name VARCHAR(20) NOT NULL,parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0); parent_id 就是该类的父类，来自 type_id，没有父类（即最大类）的 type_id为0 这种数据表的查询用到自身连接（同一个数据表对其自身进行连接）如： 查找所有分类及其父类： 1SELECT s.type_id,s.type_name,p.type_name FROM tdb_goods_types AS s LEFT JOIN tdb_goods_types AS p ON s.parent_id = p.type_id; 查找所有分类及其子类： 1SELECT p.type_id,p.type_name,s.type_name FROM tdb_goods_types AS p LEFT JOIN tdb_goods_types AS s ON s.parent_id = p.type_id; 查找所有分类及其子类的数目 1SELECT p.type_id,p.type_name,count(s.type_name) AS children_count FROM tdb_goods_types AS p LEFT JOIN tdb_goods_types AS s ON s.parent_id = p.type_id GROUP BY p.type_name ORDER BY p.type_id; 多表删除1DELETE table_name[.*] [, table_name[.*]] ... FROM table_references [WHERE where_condition]; 例如删除重复记录：1DELETE t1 FROM tdb_goods AS t1 LEFT JOIN (SELECT goods_id,goods_name FROM tdb_goods GROUP BY goods_name HAVING count(goods_name) &gt;= 2 ) AS t2 ON t1.goods_name = t2.goods_name WHERE t1.goods_id &gt; t2.goods_id; 字符函数 函数名称 描述 CONCAT() 字符连接 CONCAT_WS() 使用指定的分隔符进行字符连接 FORMAT() 数字格式化,此函数返回值是字符型 LOWER() 转换成小写字母 UPPER() 转换成大写字母 LEFT() 获取左侧字符 RIGHT() 获取右侧字符 LENGTH() 获取字符串长度（包括空格） LTRIM() 删除字符串的前导空格 RTRIM() 删除字符串的后续空格 TRIM() 删除前导和后续空格 SUBSTRING() 字符串截取 [NOT] LIKE 模式匹配 REPLACE() 字符串替换 注意：表示字符位置的数字是从1开始而不是从0开始的，起始位置的数值可以是负值，表示从后往前数例： SELECT CONCAT_WS(&#39;|&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;);结果：A|B|C SELECT FORMAT(12560.75, 1);结果：12,560.8 SELECT LOWER(LEFT(&#39;MySQL&#39;, 2));结果：my。表示把截取的前两位字符变为小写 SELECT TRIM(LEADING &#39;?&#39; FROM &#39;??My??SQL???&#39;);结果：My??SQL???。这里的LEADING表示删除前导的指定字符，TRAILING表示删除后续，BOTH表示前导和后续都删除 SELECT REPLACE(&#39;??My??SQL???&#39;, &#39;?&#39;, &#39;&#39;);结果：MySQL SELECT SUBSTRING(&#39;MySQL&#39;, 1, 2);结果：My。这里表示从第一位截取，截取两位 SELECT &#39;MYSQL&#39; LIKE &#39;M%&#39;;结果：1。1表示TRUE，%表示任意0个或多个字符，另外还有_下划线表示任意一个字符 假设数据表test有个first_name为tom%的数据，要查找出此记录，就要SELECT * FROM test WHERE first_name LIKE &#39;%1%%&#39; ESCAPE &#39;1&#39;;，表示1后面的%为普通字符串而非通配符 数值运算符与函数 名称 描述 CEIL() 进一取整（向上取整） DIV 整除，如3 DIV 4为0 FLOOR() 舍一取整（向下取整） MOD 取余数（取模，与%相同） POWER() 幂运算 ROUND() 四舍五入 TRUNCATE() 数字截取 例： SELECT POWER(2,3); 结果：8 SELECT TRUNCATE(125.59,1);结果：125.5。保留小数点后一位，舍去后面的，与四舍五入不同 比较运算符与函数 名称 描述 [NOT] BETWEEN…AND… [不]在范围之内 [NOT] IN() [不]在列出值范围内 IS [NOT] NULL [不]为空 例： SELECT 35 BETWEEN 1 AND 35;结果：1 SELECT 13 NOT IN(5, 10, 15);结果：1 SELECT 0 IS NOT NULL;结果：1 日期时间函数 名称 描述 NOW() 当前日期和时间 CURDATE() 当前日期 CURTIME() 当前时间 DATE_ADD() 日期变化 DATEDIFF() 日期差值 DATE_FORMAT() 日期格式化 例 ： SELECT DATE_ADD(&#39;2017-11-23&#39;, INTERVAL -365 DAY);结果：2016-11-23 SELECT DATE_ADD(&#39;2017-11-23&#39;, INTERVAL 3 WEEK);结果：2017-12-14 SELECT DATEDIFF(&#39;2017-11-23&#39;, &#39;2018-11-23&#39;);结果：-365 SELECT DATE_FORMAT(&#39;2017-11-23&#39;, &#39;%m/%d/%Y&#39;);结果：11/23/2017 信息函数 名称 描述 CONNECTION_ID() 连接ID DATABASE() 当前数据库 LAST_INSERT_ID() 最后插入的记录的ID号 USER() 当前用户 VERSION() 版本信息 对于LAST_INSERT_ID()函数，需要数据表里有一个AUTO_INCREMENT的id字段。另外，若是同时插入多条记录，如INSERT test(name,age) VALUES(&#39;Tom&#39;,20),(&#39;Jack&#39;,22);，这个函数只会返回第一个插入的也就是Tom的id 聚合函数 名称 描述 AVG() 平均值 COUNT() 计数 MAX() 最大值 MIN() 最小值 SUM() 求和 聚合函数的典型特点：只有一个返回值 信息函数 名称 描述 MD5() 信息摘要算法 PASSWORD() 密码算法 如果密码是为WEB页面准备的，建议使用MD5(),而PASSWORD()主要用于修改MySQL的用户密码 自定义函数 用户自定义函数(user-defined function, UDF)是一种对MySQL扩展的途径，其用法与内置函数相同 两个必要条件：参数（可以有0个或多个）、返回值（只能有一个） 函数可以返回任意类型的值，同样可以接收这些类型的参数；参数与返回值之间没有必然的内在联系 创建自定义函数1CREATE FUNCTION function_name RETURNS &#123;STRING | INTEGER | REAL | DECIMAL&#125; routine_body; 删除自定义函数用DROP FUNCTION [IF EXISTS] function_name; 关于函数体routine_body： 函数体由合法的SQL语句构成 函数体可以是简单的SELECT或INSERT语句 函数体如果为复合结构则使用BEGIN...END语句 复合结构可以包含声明、循环、控制结构 例：12CREATE FUNCTION f1() RETURNS VARCHAR(30)RETURN DATE_FORMAT(NOW(),&apos;%Y年%m月%d日 %H点:%i分:%s秒&apos;); 123CREATE FUNCTION f2(num1 SMALLINT UNSIGNED, num2 SMALLINT UNSIGNED)RETURNS FLOAT(10,2) UNSIGNEDRETURN (num1+num2)/2; 有时候需要创建有复合结构函数体的自定义函数，由于分隔符;被认为是SQL语句的结束，所以要先执行DELIMITER //修改SQL语句的结束符1234567CREATE FUNCTION adduser(username VARCHAR(20))RETURNS INT UNSIGNEDBEGININSERT test(username) VALUES (username);RETURN LAST_INSERT_ID();END// 之后就可以把分隔符修改回来和使用函数了：12DELIMITER ;SELECT adduser(&apos;Rose&apos;); 存储过程 存储过程是SQL语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理 存储过程存储在数据库内，可以由应用程序调用执行，允许用户声明变量以及进行流程控制 存储过程可以接收输入和输出类型的参数且可以存在多个返回值 存储过程只在第一次进行语法分析和编译，以后都直接调用编译结果，省略了编译环节 优点： 增强SQL语句的功能和灵活性 实现较快的执行速度 减少网络流量 创建存储过程12345CREATE[DEFINER = &#123;user | CURRENT_USER&#125;]PROCEDURE sp_name ([proc_parameter[,...]])[characteristic ...]routine_body DEFINER是创建者，省略的话默认是当前登录到MySQL的用户 sp_name是存储过程的名字 proc_parameter是参数，可以有0到多个，写法：[IN | OUT | INOUT]param_name type。注意： 参数名不要和数据表字段名重名 IN，表示该参数的值必须在调用存储过程时指定，该值不能被返回 OUT，表示该参数的值可以被存储过程改变，并且可以被返回 INOUT，表示该参数的值在调用时指定，并且可以被改变和返回 characteristic特性，与自定义函数相似： COMMENT：注释 CONTAINS SQL：包含SQL语句，但不包含读或写数据的语句 NO SQL：不包含SQL语句 READS SQL DATA：包含读数据的语句 MODIFIES SQL DATA：包含写数据的语句 SQL SECURITY {DEFINER | INVOKER}：指明谁有权限来执行1COMMENT &apos;string&apos; | &#123;CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA&#125; | SQL SECURITY &#123;DEFINER | INVOKER&#125; routine_body过程体： 过程体由合法的SQL语句构成 过程体可以是任意SQL语句（主要指对记录的增删改查及多表连接等而非对数据库数据表本身的修改） 过程体如果为复合结构则使用BEGIN...END语句 复合结构可以包含声明、循环、控制结构 调用存储过程12CALL sp_name([parameter[,...]]);CALL sp_name[()]; 修改存储过程和修改自定义函数相似，只能修改以下简单的选项，不能修改过程体，要修改过程体只能删除该存储过程然后重新创建1ALTER PROCEDURE sp_name [characteristic ...] COMMENT &apos;string&apos; | &#123;CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA&#125; | SQL SECURITY &#123;DEFINER | INVOKER&#125;; 删除存储过程删除时不用带参数，只用存储过程名称1DROP PROCEDURE [IF EXISTS] sp_name; 创建不带参数的存储过程例：1CREATE PROCEDURE sp1() SELECT VERSION(); 调用：因为不带参数，所以CALL sp1;或CALL sp1();都可以 创建带有IN类型参数的存储过程和创建自定义函数一样要先使用DELIMITER //修改结束符123456789DELIMITER //CREATE PROCEDURE removeUserById(IN p_id INT UNSIGNED)BEGINDELETE FROM test WHERE id = p_id;END//DELIMITER ; 创建带有IN和OUT类型参数的存储过程12345678910DELIMITER //CREATE PROCEDURE removeUserAndReturnUserCount(IN p_id INT UNSIGNED,OUT userCount INT UNSIGNED)BEGINDELETE FROM test WHERE id = p_id;SELECT count(id) FROM test INTO userCount;END//DELIMITER ; 调用：12CALL removeUserAndReturnUserCount(37,@nums);SELECT @nums; 其中，@nums是变量，在BEGIN...END间用DECLEAR声明的变量叫局部变量，作用域只在BEGIN...END之间。而且在BEGIN...END间DECLEAR语句必须位于第一行。而像上面SELECT...INTO para_name或SET @para_name = ...声明的变量叫用户变量，对当前用户使用的客户端有效 创建带有多个OUT类型参数的存储过程ROW_COUNT() 函数可以得到被影响（即插入、删除或更新）的记录数1234567891011DELIMITER //CREATE PROCEDURE removeUserByAgeAndReturnInfos(IN p_age SMALLINT UNSIGNED, OUT deleteUsers SMALLINT UNSIGNED, OUT userCounts SMALLINT UNSIGNED)BEGINDELETE FROM test WHERE age = p_age;SELECT ROW_COUNT() INTO deleteUsers;SELECT COUNT(id) FROM test INTO userCounts;END//DELIMITER ; 调用：12CALL removeUserByAgeAndReturnInfos(20,@a,@b);SELECT @a,@b; 存储过程与自定义函数的区别 存储过程实现的功能要复杂一些；而函数的针对性更强（针对表做操作一般使用存储过程） 存储过程可以返回多个值；函数只能有一个返回值 存储过程一般独立来执行；而函数可以作为其他SQL语句的组成部分来出现 二者注意事项： 创建存储过程或者自定义函数时需要通过delimiter语句修改定界符 如果函数体或过程体有多个语句，需要包含在BEGIN...END语句块中 存储引擎MySQL可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。每一种存储引擎使用不同的存储机制、索引技巧、锁定水平，最终提供广泛且不同的功能 分类： MyISAM InnoDB Memory Archive CSV（不支持索引） BlackHole：黑洞引擎，写入的数据都会消失，一般用于做数据复制的中继 并发控制当多个连接对记录进行修改时要保证数据的一致性和完整性，就要使用并发控制。处理并发读或并发写时系统会使用锁系统： 共享锁（读锁）：在同一时间段内，多个用户可以读取同一个资源，读取过程中数据不会发生任何变化 排它锁（写锁）：在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其他的读锁或者写锁操作 锁颗粒： 表锁，是一种开销最小的锁策略 行锁，是一种开销最大的锁策略 事务处理事务用于保证数据库的完整性 事务的特性： 原子性(Atomicity) 一致性(Consistency) 隔离性(Isolation) 持久性(Durability) 外键和索引外键是保证数据一致性的策略；索引是对数据表中一列或多列的值进行排序的一种结构，包括：普通索引、唯一索引、全文索引、btree索引、hash索引…… 各种存储引擎的特点 特点 MyISAM InnoDB Memory Archive 存储限制 256TB 64TB 有 无 事务安全 - 支持 - - 支持索引 支持 支持 支持 - 锁颗粒 表锁 行锁 表锁 行锁 数据压缩 支持 - - 支持 支持外键 - 支持 - - 使用得比较多的是MyISAM和InnoDB。MyISAM适用于事务的处理不多的情况；InnoDB适用于事务处理较多，需要有外键支持的情况 修改存储引擎 通过修改MySQL配置文件实现：default-storage-engine= engine_name，默认是InnoDB 通过创建数据表或修改数据表命令实现：1234CREATE TABLE table_name(......)ENGINE = engine_name; 1ALTER TABLE table_name ENGINE [=] engine_name;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
