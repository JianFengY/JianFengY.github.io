<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python基础语法篇（1）]]></title>
    <url>%2FPython%2FPython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简介Python是吉多·范罗苏姆在1989年的圣诞节创立的。经过二十多年的完善，已经成为了一个优秀并广泛使用的语言。 Python可以应用于数据分析、组件集成、网络服务、图像处理、数值计算和科学计算等众多领域。 诸如Youtube、Dropbox、Quora、豆瓣、知乎、Google、Yahoo!、Facebook、百度、腾讯等公司都有使用Python。 编译型&amp;解释型Python是解释型语言，程序不需要编译，在运行程序的时候才翻译成机器语言，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就需要逐行翻译一次，效率比较低。 而编译型语言在程序执行之前，有一个单独的编译过程，将程序翻译成机器语言，以后执行这个程序的时候，就不用再进行翻译了。典型的有C、C++。 编译型语言就相当于做好一桌子菜再开吃，而编译型语言就相当于吃火锅… 静态语言&amp;动态语言Python是一门动态语言，动态类型语言是在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，不用给变量指定数据类型。此外，Ruby、JavaScript也是动态语言。 静态语言则是在编译期间做类型判断，如C、C++等。 强类型定义语言&amp;弱类型定义语言强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言。 弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。 Python是动态语言，也是强类型定义语言（类型安全的语言）；VBScript是动态语言，是弱类型定义语言（类型不安全的语言）；JAVA是静态语言，是强类型定义语言（类型安全的语言）。 Python2.x&amp;Python3.x官方有一句话： In summary : Python 2.x is legacy, Python 3.x is the present and future of the language 2和3详细的区别这里就不说了，最大的改动就是Python3.x里所有文本字符串默认为Unicode编码，意味着可以直接写中文，开头不需要# -*- coding:utf-8 -*-了。 Hello World!Windows下在官网下载安装程序直接安装，安装时勾上Add Python 3.6 to PATH。 安装好后在命令行输入python输入:12&gt;&gt;&gt; print(&apos;hello, world&apos;)hello, world Linux下想类似于执行shell脚本一样执行python脚本，例：./hello.py要在第一行加上指定解释器，env指里寻找python环境变量：1#!/usr/bin/env python 记得执行前需给予hello.py执行权限，chmod 755 hello.py 变量 变量名只能是 字母、数字或下划线的任意组合 变量名的第一个字符不能是数字 以下关键字不能声明为变量名：[&#39;and&#39;, &#39;as&#39;, &#39;assert&#39;, &#39;break&#39;, &#39;class&#39;, &#39;continue&#39;, &#39;def&#39;, &#39;del&#39;, &#39;elif&#39;, &#39;else&#39;, &#39;except&#39;, &#39;exec&#39;, &#39;finally&#39;, &#39;for&#39;, &#39;from&#39;, &#39;global&#39;, &#39;if&#39;, &#39;import&#39;, &#39;in&#39;, &#39;is&#39;, &#39;lambda&#39;, &#39;not&#39;, &#39;or&#39;, &#39;pass&#39;, &#39;print&#39;, &#39;raise&#39;, &#39;return&#39;, &#39;try&#39;, &#39;while&#39;, &#39;with&#39;, &#39;yield&#39;] 1234567name = &quot;Jack&quot;name2 = name # name2不是指向name而是指向name的值&quot;Jack&quot;print(&quot;My name is &quot;, name) # My name is Jackprint(name, name2) # Jack Jackname = &quot;Tom&quot; # 只有name变了，name2不会变print(name, name2) # Tom Jack 字符编码ASCII（American Standard Code for Information Interchange，美国标准信息交换代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言，其最多只能用 8 位来表示（一个字节），即：2**8 = 256-1，所以，ASCII码最多只能表示 255 个符号。 为了处理中文，程序员设计了用于简体中文的GB2312和用于繁体中文的big5。GB2312(1980年)一共收录了7445个字符，包括6763个汉字和682个其它符号。汉字区的内码范围高字节从B0-F7，低字节从A1-FE，占用的码位是72*94=6768。其中有5个空位是D7FA-D7FE。 1995年的汉字扩展规范GBK1.0收录了21886个符号，它分为汉字区和图形符号区。汉字区包括21003个字符。2000年的 GB18030是取代GBK1.0的正式国家标准。该标准收录了27484个汉字，同时还收录了藏文、蒙文、维吾尔文等主要的少数民族文字。现在的PC平台必须支持GB18030，对嵌入式产品暂不作要求。所以手机、MP3一般只支持GB2312。 显然ASCII码无法将世界上的各种文字和符号全部表示，所以，就需要新出一种可以代表所有字符和符号的编码，即：Unicode（统一码、万国码、单一码）是一种在计算机上使用的字符编码。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，规定虽有的字符和符号最少由 16 位来表示（2个字节），即：2 **16 = 65536。 UTF-8，是对Unicode编码的压缩和优化，他不再使用最少使用2个字节，而是将所有的字符和符号进行分类：ascii码中的内容用1个字节保存、欧洲的字符用2个字节保存，东亚的字符用3个字节保存。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己写一个Chrome插件]]></title>
    <url>%2FChrome%2F%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%80%E4%B8%AAChrome%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[这篇文章也是之前在公众号上发布过的，现在整理一下发上来，如果这里分析的廖雪峰老师的网站结构有改变，代码可能也要重新分析编写。 另外，很多时候，使用Tampermonkey写用户脚本会更加方便，而且也可以使用别的许多大牛写的脚本，也推荐大家使用。我这篇文章只是写一下制作插件的过程。 前言前段时间在看廖雪峰老师网站的JavaScript教程时，发现有很多图片广告，看得我很是不舒服。于是决定写一个Chrome插件屏蔽一下。并不是说挂广告有什么不对，只是单纯地想折腾一下…… 所以这里就记录下我是怎么做的。 准备工作首先当然是F12看源码了，我们可以找到图片广告的div。可以看到两个div的class都有uk-clearfix,我们用hide()方法就可以这些图片隐藏了。 编写js代码以下代码就可以把图片去掉了：1$(&apos;.uk-clearfix&apos;).hide(); 然后我就想了，既然要去广告，那就再去得干净一点吧，左侧还有一个关于作者的廖雪峰老师的微博…… 于是找到class为x-sidebar-left-bottom：1$(&apos;.x-sidebar-left-bottom&apos;).hide(); 还有下面的分享部分，可以看到这些是分开的。 这里我是通过找到他们的前一个元素来去定位的：1$(&apos;.x-wiki-content&apos;).next().next().andSelf().next().andSelf().next().andSelf().hide(); 之后评论这一部分： 本来我想直接去除，但是觉得有些评论还是挺有用的，所以就做成了可以通过点击评论让评论列表隐藏或显示，还让鼠标移到“评论”上就变成手指哈哈：12345$(&apos;.x-anchor&apos;).next().mousemove(function()&#123; $(this).css(&quot;cursor&quot;,&quot;pointer&quot;);&#125;).on(&apos;click&apos;, function () &#123; $(&apos;#x-comment-list&apos;).toggle();&#125;); 还有一个提示登录评论的我就直接去掉了：1$(&apos;#x-comment-list&apos;).next().next().andSelf().hide(); 制作插件这里先准备以下文件： icon就是安装后显示的图标，一个jQuery的js文件，另一个js就是刚才自己编写的js脚本：1234567891011window.onload = function () &#123; $(&apos;.uk-clearfix&apos;).hide(); $(&apos;.x-anchor&apos;).next().mousemove(function()&#123; $(this).css(&quot;cursor&quot;,&quot;pointer&quot;); &#125;).on(&apos;click&apos;, function () &#123; $(&apos;#x-comment-list&apos;).toggle(); &#125;); $(&apos;.x-sidebar-left-bottom&apos;).hide(); $(&apos;.x-wiki-content&apos;).next().next().andSelf().next().andSelf().next().andSelf().hide(); $(&apos;#x-comment-list&apos;).next().next().andSelf().hide();&#125; manifest.json就相当于这个插件的配置文件了：1234567891011121314151617181920&#123; &quot;manifest_version&quot;: 2, &quot;name&quot;: &quot;LiaoXueFeng&quot;, &quot;description&quot;: &quot;Don&apos;t tell others!&quot;, &quot;version&quot;: &quot;1.0&quot;, &quot;permissions&quot;: [ &quot;https://www.liaoxuefeng.com/*&quot; ], &quot;browser_action&quot;: &#123; &quot;default_icon&quot;: &quot;icon.png&quot;, &quot;default_title&quot;: &quot;Remove somthing!&quot; &#125;, &quot;content_scripts&quot;: [ &#123; &quot;matches&quot;: [&quot;https://www.liaoxuefeng.com/*&quot;], &quot;js&quot;: [&quot;jquery-1.10.2.min.js&quot;,&quot;Liaoxuefeng.js&quot;], &quot;run_at&quot;: &quot;document_start&quot; &#125; ]&#125; 接下来就是打开Chrome的扩展程序界面，点击打包扩展程序这里选了根目录就行，密钥文件是用来更新扩展程序用的： 之后生成了crx文件，就完成了！pem文件就是刚才说的密钥文件了。 然后就可以安装使用了，以后打开这个网页就变得清爽多了：]]></content>
      <categories>
        <category>Chrome</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python获取Bing图片做壁纸]]></title>
    <url>%2FPython%2FPython%E8%8E%B7%E5%8F%96Bing%E5%9B%BE%E7%89%87%E5%81%9A%E5%A3%81%E7%BA%B8%2F</url>
    <content type="text"><![CDATA[这篇东西是之前发在微信公众号上的文章，现在整理一下发出来。 前言用过Bing搜索的都知道，它首页每天都会更新一张图片，点击这里可以访问。 先说说结果吧，写了一个有GUI界面的小工具，可以查看和保存壁纸，有兴趣的可以在公众号回复“bing”下载玩玩。也可以点击我的GitHub下载Main.exe试试。 需要注意的一些问题： 工具需要联网才能打开 暂时不支持更改保存的文件夹 设为壁纸之后注销或重启之后就无效了（用保存的图片手动设置壁纸的话就没问题。我在win10用的时候是这样，其他系统不知道，可能是用的pywin32这个库的问题。） 好了，不想看分析和代码的看到这里就好了。 准备工作（python 3.x环境） 获取网页信息的requests，urllib库 设置壁纸的pywin32，PIL库 编写GUI的pyqt5库 分析网页和以前一样，第一步就是打开网页开发者工具，发现在代码里是找不到图片的网址的，这时候就要看networks了：我们可以在XHR里发现下面这个请求：1https://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;nc=1510118759864&amp;pid=hp 请求的结果格式化之后是这样的：123456789101112131415161718192021222324252627&#123; &quot;images&quot;: [ &#123; &quot;startdate&quot;: &quot;20171107&quot;, &quot;fullstartdate&quot;: &quot;201711071600&quot;, &quot;enddate&quot;: &quot;20171108&quot;, &quot;url&quot;: &quot;/az/hprichbg/rb/PointArenaLH_ZH-CN12332642727_1920x1080.jpg&quot;, &quot;urlbase&quot;: &quot;/az/hprichbg/rb/PointArenaLH_ZH-CN12332642727&quot;, &quot;copyright&quot;: &quot;波因特阿里纳灯塔，美国加利福尼亚州 (© plainpicture/Westend61/Spotcatch)&quot;, &quot;copyrightlink&quot;: &quot;/search?q=Point+Arena+Ligh&amp;form=hpcapt&amp;mkt=zh-cn&quot;, &quot;quiz&quot;: &quot;/search?q=Bing+homepage+quiz&amp;filters=WQOskey:%22HPQuiz_20171107_PointArenaLH%22&amp;FORM=HPQUIZ&quot;, &quot;wp&quot;: true, &quot;hsh&quot;: &quot;ea5b137418244ac63db363f7276c95bb&quot;, &quot;drk&quot;: 1, &quot;top&quot;: 1, &quot;bot&quot;: 1, &quot;hs&quot;: [ ] &#125; ], &quot;tooltips&quot;: &#123; &quot;loading&quot;: &quot;正在加载...&quot;, &quot;previous&quot;: &quot;上一个图像&quot;, &quot;next&quot;: &quot;下一个图像&quot;, &quot;walle&quot;: &quot;此图片不能下载用作壁纸。&quot;, &quot;walls&quot;: &quot;下载今日美图。仅限用作桌面壁纸。&quot; &#125;&#125; 没错，“url”加上域名就是图片的地址了，“enddate”的值就是当天日期，可以作为保存的文件名。另外，请求的链接里有个“idx”参数，0是今天的图片，1是昨天的，以此类推。知道这个，接下来的事就很简单了。 编写代码首先先写一个获取url的函数，因为要让程序可以获取到前些天的图片，参数的默认值为0，也就是今天的图片：123def get_url(day=0): url = &quot;https://www.bing.com/HPImageArchive.aspx?format=js&amp;idx=&quot; + str(day) + &quot;&amp;n=1&amp;nc=1509675905008&amp;pid=hp&amp;video=1&quot; return url 然后，写一个保存图片的函数，用“enddate”作为文件名：12345678def get_img(url, path=&quot;D://wallpaper/&quot;): isExists = os.path.exists(path) if not isExists: os.makedirs(path) html = requests.get(url) content = html.json() src = &quot;https://www.bing.com&quot; + content[&apos;images&apos;][0][&apos;url&apos;] urlretrieve(src, path + content[&apos;images&apos;][0][&apos;enddate&apos;] + &apos;.jpg&apos;) 设置壁纸的方法来自网上，原理是通过pywin32访问注册表修改壁纸，至于为什么注销或重启之后会无效我也不是太懂……12345678910111213141516def set_wallpaper_from_bmp(bmp_path): reg_key = win32api.RegOpenKeyEx(win32con.HKEY_CURRENT_USER, &quot;Control Panel\\Desktop&quot;, 0, win32con.KEY_SET_VALUE) win32api.RegSetValueEx(reg_key, &quot;WallpaperStyle&quot;, 0, win32con.REG_SZ, &quot;2&quot;) win32api.RegSetValueEx(reg_key, &quot;TileWallpaper&quot;, 0, win32con.REG_SZ, &quot;0&quot;) win32gui.SystemParametersInfo(win32con.SPI_SETDESKWALLPAPER, bmp_path, win32con.SPIF_SENDWININICHANGE) def set_wallpaper(img_path): isExists = os.path.exists(img_path) if isExists: img_dir = os.path.dirname(img_path) bmpImage = Image.open(img_path) new_bmp_path = os.path.join(img_dir, &apos;wallpaper.bmp&apos;) bmpImage.save(new_bmp_path, &quot;BMP&quot;) set_wallpaper_from_bmp(new_bmp_path) return True else: return False 最后是用pyqt5写GUI界面，我也是第一次使用，所以不是太好看，代码也有点乱，大家凑和看看吧哈哈……12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Bing(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(400, 200, 500, 325) self.setFixedSize(self.width(), self.height()); self.setWindowTitle(&apos;Bing Wallpaper&apos;) self.setWindowIcon(QIcon(&apos;Bing.ico&apos;)) self.add_position_layout() # 添加布局部件 def add_position_layout(self): bg_label = QLabel(self) bg_label.resize(self.width(), self.height()) bg_label.setScaledContents(True) def set_background_image(img): photo = QtGui.QPixmap() photo.loadFromData(img) bg_label.setPixmap(photo)# img = time.strftime(&quot;%Y%m%d&quot;) + &apos;.jpg&apos; img, self.filename = sp.show_img(sp.get_url()) set_background_image(img)# label_1 = QLabel(&quot;&lt;p style=&apos;font-size:25px;text-align:center;&apos;&gt;&lt;b&gt;Path:&lt;/b&gt;&lt;/p&gt;&quot;, self) label_1 = QLabel(&quot; 保存目录: &quot;, self) label_1.setStyleSheet(&quot;QLabel&#123;background:rgb(255,255,255,100)&#125;&quot;) path_edit = QLineEdit() path_edit.setText(&apos;D:/wallpaper&apos;) path_edit.setToolTip(&apos;抱歉！暂时不支持更换路径！&apos;) path_edit.setReadOnly(True)# def btn_change():# filename = QFileDialog.getExistingDirectory(self, directory=path_edit.text())# path_edit.setText(filename) self.day = 0 def btn_previous(day): img,self.filename = sp.show_img(sp.get_url(self.day + 1)) set_background_image(img) self.day += 1 print(self.day) def btn_next(day): if self.day &gt; 0: img,self.filename = sp.show_img(sp.get_url(self.day - 1)) set_background_image(img) self.day -= 1 print(self.day) else: QMessageBox.information(self, &quot; &quot;, &quot;明天的壁纸还未更新哦！&quot;) def btn_save(day): img = sp.get_img(sp.get_url(self.day)) def btn_set_wallpaper(day): flag = sw.set_wallpaper(&apos;D:/wallpaper/&apos; + self.filename) if not flag: QMessageBox.information(self, &quot; &quot;, &quot;请先保存此壁纸!&quot;) # button_1 = QPushButton(&quot;更改路径&quot;, self)# button_1.clicked.connect(btn_change) button_2 = QPushButton(&quot;前一张&quot;, self) button_2.setToolTip(&apos;查看前一天的必应图片！&apos;) button_2.clicked.connect(btn_previous) button_3 = QPushButton(&quot;设为壁纸&quot;, self) button_3.setToolTip(&apos;设置壁纸要先保存哦！&apos;) button_3.clicked.connect(btn_set_wallpaper) button_4 = QPushButton(&quot;保存&quot;, self) button_4.setToolTip(&apos;保存在该目录下！&apos;) button_4.clicked.connect(btn_save) button_5 = QPushButton(&quot;后一张&quot;, self) button_5.setToolTip(&apos;查看后一天的必应图片！&apos;) button_5.clicked.connect(btn_next) grid = QGridLayout() grid.setSpacing(10) grid.addWidget(label_1, 2, 0) grid.addWidget(path_edit, 2, 1, 1, 2)# grid.addWidget(button_1, 2, 3) grid.addWidget(button_2, 3, 0) grid.addWidget(button_3, 3, 1, 1, 2) grid.addWidget(button_4, 2, 3) grid.addWidget(button_5, 3, 3) grid.setAlignment(Qt.AlignTop) layout_widget = QWidget() layout_widget.setLayout(grid) self.setCentralWidget(layout_widget)if __name__ == &apos;__main__&apos;: sp.get_img(sp.get_url()) app = QApplication(sys.argv) bing = Bing() bing.show() sys.exit(app.exec_()) 简单来说，程序会先通过网络获取图片显示，所以没有联网的话就用不了，要设置壁纸的话需要先点击保存会把图片保存下来，运行结果是这样的： 结语另外，完成之后，我用pyinstaller打包成了exe文件，打包完之后我发现左上角的那个小图标没了，不过不影响使用……大家在公众号回复“bing”就有下载地址了，或者点击我的GitHub，有源码也有exe程序，注意一下前面说的几个问题就好。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fiddler分析手机App请求Scrapy爬虫]]></title>
    <url>%2FPython%2F%E7%88%AC%E8%99%AB%2FFiddler%E5%88%86%E6%9E%90%E6%89%8B%E6%9C%BAApp%E8%AF%B7%E6%B1%82Scrapy%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[Fiddler是一款十分强大的调试代理工具，这个工具我就不详细介绍了。简单来说，它是通过创建代理，拦截http请求用于分析或修改。 这里就演示一下用Fiddler抓取手机端Bilibili的请求并使用Scrapy编写一个爬取图片的爬虫程序。 准备环境 Python，我用的是3.6，系统是win10 Scrapy框架，安装过程我之前的文章提过 Fiddler，点击这里下载安装 手机…我的是安卓 一个安卓软件，我这里就用Bilibili示范 Fiddler配置安装我就不说了，说说配置，Tools - Connections这里可以看到默认端口号是很吉利的8888。这里要勾上Allow remote computers to connect。然后要让手机和电脑连接上同一个网络，并给手机设置代理IP，设置成电脑的IP地址，cmd执行命令ipconfig可以查看ip：手机连接上wifi后，选择代理设置，把服务器设置成刚才看到的IP地址，端口号如果没改的话就是8888，然后保存。下面是给手机安装证书，不安装可能会出现手机设置了代理无法上网的问题。 然后手机浏览器访问ip地址:8888，下载证书安装：打开设置 - 安全 - 设备管理与凭证 - 从存储盘安装，差不多都是这个地方，找找应该能找到…安装完后可以在用户凭证可以看到： 分析请求接下来就可以打开Fiddler还有手机端的Bilibili，进行分析了。我这里选择相簿，准备爬取里面的图片。下面的精选热推就是我们的目标：刷新手机的时候，可以看到Fiddler界面出现了请求的链接返回的是json数据：复制链接到浏览器打开就可以看到图片地址了：点开这个地址，可以看到刚才手机端显示的那张图片：接下来手机端往下拉，在Fiddler可以看到刷出了相似的请求，可以看到请求的参数里，page_num参数增加，这就是表示页码的参数： 编写代码现在，图片的网址我们已经找出来了，接下来就可以编写代码下载图片了，这里我还是使用了Scrapy框架。 首先，还是新建项目：1scrapy startproject scrapy_bilibili 然后编写items.py定义存储字段：123456789import scrapyclass ScrapyBilibiliItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() image_urls = scrapy.Field() images = scrapy.Field() image_paths = scrapy.Field() 然后settings.py把ITEM_PIPELINES注释取消，还有增加IMAGES_STORE作为存储位置，还把USER_AGENT改成了Fiddler看到的值：1234567ITEM_PIPELINES = &#123; &apos;scrapy_bilibili.pipelines.ScrapyBilibiliPipeline&apos;: 300,&#125;IMAGES_STORE = &apos;E:/scrapy_bilibili/images&apos;USER_AGENT = &apos;Mozilla/5.0 BiliDroid/5.22.1 (bbcallen@gmail.com)&apos; 接下来是pipelines.py，这段代码改自官方文档：123456789101112131415161718import scrapyfrom scrapy.pipelines.images import ImagesPipelinefrom scrapy.exceptions import DropItemfrom scrapy.utils.project import get_project_settingsclass ScrapyBilibiliPipeline(ImagesPipeline): IMAGES_STORE = get_project_settings().get(&apos;IMAGES_STORE&apos;) def get_media_requests(self, item, info): image_url = item[&apos;image_urls&apos;] yield scrapy.Request(image_url) def item_completed(self, results, item, info): image_paths = [x[&apos;path&apos;] for ok, x in results if ok] if not image_paths: raise DropItem(&quot;Item contains no images&quot;) item[&apos;image_paths&apos;] = image_paths return item 最后在spiders文件夹里新建bilibili_spider.py放置爬虫的代码：123456789101112131415161718192021import jsonimport scrapyfrom scrapy_bilibili.items import ScrapyBilibiliItemclass BilibiliSpider(scrapy.Spider): name = &apos;bilibili_spider&apos; allowed_domains = [&apos;api.vc.bilibili.com&apos;] page_num = 0 start_urls = [&apos;http://api.vc.bilibili.com/link_draw/v2/Doc/...&amp;page_num=&apos; + str(page_num) + &apos;&amp;page_size=20...&apos;] # 链接太长我就不放完整了 def parse(self, response): datas = json.loads(response.text)[&apos;data&apos;][&apos;items&apos;] for data in datas: item = ScrapyBilibiliItem() for img in data[&apos;item&apos;][&apos;pictures&apos;]: item[&apos;image_urls&apos;] = img[&apos;img_src&apos;] yield item if self.page_num &gt;= 10: return self.page_num += 1 yield scrapy.Request(&apos;http://api.vc.bilibili.com/link_draw/v2/Doc/...&amp;page_num=&apos; + str(self.page_num) + &apos;&amp;page_size=20...&apos;, callback = self.parse) # 链接也是不完整的 运行代码在项目的目录下执行以下命令，注意bilibili_spider是bilibili_spider.py里class的name：1scrapy crawl bilibili_spider 然后，等到运行完，就能看到结果了，图片是使用它们URL的 SHA1 hash 作为文件名的： 对了，这里要注意一个问题，运行的时候如果有挂代理，比如一些科学^_^上网的工具什么的就先关掉吧，不然可能会出现以下问题：1Connection to the other side was lost in a non-clean fashion: Connection lost. 到这里，我们的程序就完成了。]]></content>
      <categories>
        <category>Python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
        <tag>爬虫</tag>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客设置以及Next主题美化]]></title>
    <url>%2FHexo%2FHexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[之前的一篇文章写了用Hexo和GitHub搭建博客，现在就来对博客主题做一些个性化的修改。 安装Next主题切换到博客的目录，使用Git Bash运行下载主题：1git clone https://github.com/iissnan/hexo-theme-next themes/next 然后打开根目录下的_config.yml，注意这个是整个博客站点的配置文件，而主题目录下也有一个_config.yml，这是主题的配置文件。在站点配置文件找到theme改为next：1theme: next 这样就启用了主题，可以运行hexo s查看效果了。 博客设置这里先对博客基本信息做一些设置，注意了，设置时冒号后面都要有一个空格，这是yml文件的格式 设置语言首先先设置博客站点的语言，这个是在站点配置文件，也就是根目录下的_config.yml设置的，找到language设置成中文：1language: zh-Hans 基本信息在站点配置文件的开头，填上自己博客的相应信息：123456title: # 标题subtitle: # 副标题description: # 站点描述author: # 作者language: zh-Hanstimezone: 主题设置Next已经自带了很多功能和集成了一些第三方服务，通过主题目录下的_config.yml就能对主题做一些设定及个性化。 设置主题的SchemeNext自带了几种外观，在主题目录的_config.yml里找到scheme，我比较喜欢Mist，把前面的注释符#去掉即可：1234#scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini 菜单设置我们可以看到首页有还有归档等菜单，这些在主题配置文件里设置，找到menu，把需要的菜单取消注释，我这里保留了categories分类，tags标签，archives归档，about关于，||后面的表示图标，使用Font Awesome图标名字。我就不作修改了：123456789menu: home: / || home categories: /categories/ || th tags: /tags/ || tags archives: /archives/ || archive about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 另外，也可以自己添加菜单，但我暂时没有这个需要。 创建页面设置完菜单但是没有页面的话点击菜单就会报错了。创建刚才建了菜单的页面执行以下命令：123hexo new page tagshexo new page categorieshexo new page about 然后在source目录下就会生成对应的文件夹，每个文件夹里都有一个index.md，打开将页面的type设置为相应的内容。12345title: 标签date: type: &quot;tags&quot; # 或者 &quot;categories&quot;/&quot;about&quot;comments: false--- comments是关闭这个页面的评论功能用的，评论后面会提到。 文章显示设置默认首页的文章会显示全文，在主题配置文件设置auto_excerpt为true再设置长度就会只显示你设置的字数了。123auto_excerpt: enable: true length: 100 但是，官方是不推荐这种做法的，我这里用的方法是发表的文章的开头加上description，这样，文章就会显示这个摘要：1234567891011title: # 文章标题author: # 作者tags: - Hexo - Nextcategories: - Hexo - Nextdescription: # 描述，首页文章显示的摘要date: --- 这里的tags和categories就是给文章加上标签和分类，两者的区别就是categories是有层级的，像上面那样分类里Next就是Hexo的子类，Hexo是不支持指定多个同级分类的。 使用RSS先在博客目录下执行以下命令安装插件：1npm install --save hexo-generator-feed 然后在主题配置文件里找到rss修改：1rss: /atom.xml 之后在右边的侧边栏就能看到RSS按钮了 设置头像在source目录下新建一个images目录，放一张名为avatar.png的头像，修改主题配置文件的avatar字段：1avatar: /images/avatar.png 设置博客favicon图标在images目录下放置图标，我这里放了两种大小的ico图标，然后在主题配置文件找到favicon并修改：1234567favicon: small: /images/favicon-16x16.ico medium: /images/favicon-32x32.ico #apple_touch_icon: /images/apple-touch-icon-next.png #safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 侧边栏社交链接在主题配置文件找到social把需要的取消注释，然后填好你的链接就可以了，||后面的是图标名称，和菜单的一样，也是使用Font Awesome图标名字。1234567891011social: GitHub: https://github.com/JianFengY || github GMail: mailto:yjianfengxy@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter Facebook: https://www.facebook.com/jf.young.1 || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 你也可以自行添加其他社交方式，按照格式添加即可。 设置背景动画同样是主题配置文件，我这里用的是canvas_nest：1234567891011# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false 修改文章底部的#号标签打开/themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将#换成Font Awesome图标:1&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 评论系统我使用的是来必力 点击这里 注册账号，然后复制下面的data-uid： 在主题配置文件找到livere_uid：123# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: # 粘贴你的uid 这样，除了设置了comments: false的页面，其他都会有评论系统了。 网站底部加访问量这个我是通过修改\themes\next\layout\_partials\footer.swig文件实现的:12345678910&lt;div class=&quot;powered-by&quot;&gt; &lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt; &lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; &lt;/span&gt; &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt; &lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; &lt;/span&gt;&lt;/div&gt; 统计功能先在博客目录下安装插件：1npm install hexo-wordcount --save 然后在主题配置文件，找到post_wordcount，修改你想要的统计功能，有字数统计，阅读时长等：12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: true totalcount: true separated_meta: true LeanCloud文章阅读次数统计点击这里 注册登录LeanCloud账号，先创建一个任意名称的应用，再创建一个名为Counter的Class。在应用Key这里分别复制App ID和App Key到主题配置文件里的leancloud_visitors，并把enable改为true。123456# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: app_key: 然后最好再设置一下安全域名就可以了： 搜索服务Local Search先安装hexo-generator-searchdb，博客目录执行：1npm install hexo-generator-searchdb --save 然后在站点配置文件，注意不是主题配置，添加以下代码：12345search: path: search.xml field: post format: html limit: 10000 然后主题配置文件找到local_search改为true，然后从上面提供的样式选一个填入pace_theme中就可以了：123# Local searchlocal_search: enable: true 然后菜单就会出现搜索了。 顶部加载条修改主题配置文件，找到pace改为true，并从上面提供的样式中选择一种填入pace_theme中就可以了：12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal 右上角加fork me on github点击这里或者这里挑选你喜欢的样式，修改成你的GitHub链接，复制到themes/next/layout/_layout.swig文件中的以下位置：123&lt;div class=&quot;&#123;&#123; container_class &#125;&#125; &#123;% block page_class %&#125;&#123;% endblock %&#125;&quot;&gt; &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; &lt;a href=&quot;https://github.com/JianFengY&quot; ......&lt;/a&gt; 浏览文章时显示浏览进度主题设置文件查找scrollpercent修改为true：12# Scroll percent label in b2t button.scrollpercent: true 修改文章内链接的样式文章里的链接样式默认是只加一条下划线，颜色和普通文字一样，为了方便区分，在themes/next/source/css/_custom/custom.styl文件加以下代码，自行添加的样式都可以写在这个文件里：12345678910.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125; &#125; 致谢这个博客从搭建到美化，都参考了网上许多文章和教程，我就不一一罗列出来了，感谢网上各路大神！ 这里推荐一篇干货满满的文章：https://www.jianshu.com/p/f054333ac9e6 还有就是官方的文档了，里面也有很详细的主题配置和第三方服务的说明：http://theme-next.iissnan.com/third-party-services.html]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫Scrapy入门篇]]></title>
    <url>%2FPython%2F%E7%88%AC%E8%99%AB%2FPython%E7%88%AC%E8%99%ABScrapy%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言因为Python简单灵活的特点，一直是写爬虫的热门语言，我之前也在公众号上分享过几篇简单的爬虫例子和教程。 Scrapy是一款简单高效的Python网络爬虫框架，使用框架，我们就可以只关注数据的提取而不用去自己造轮子了。其实，对于这个框架，我也是个新手…这里，就用我们学校的图书馆系统做个简单的入门项目了。 安装先说一下我的Python是3.6版本的，电脑是win10。 Scrapy也可以直接用使用pip命令安装：1pip install scrapy 因为Scrapy依赖了其他一些包，所以会额外安装一些库，如lxml、Twisted和pyOpenSSL等，这在文档也有提到。我在安装这些库时有遇到一个问题，报了下面这个错误：1Command &quot;&quot;d:\program files\python3.6.1\python.exe&quot; -u -c &quot;import setuptools, tokenize;__file__=&apos;C:\\Users\\ASUS\\AppData\\Local\\Temp\\pip-build-qkm97m8f\\Twisted\\setup.py&apos;;f=getattr(tokenize, &apos;open&apos;, open)(__file__);code=f.read().replace(&apos;\r\n&apos;, &apos;\n&apos;);f.close();exec(compile(code, __file__, &apos;exec&apos;))&quot; install --record C:\Users\ASUS\AppData\Local\Temp\pip-e4cf8gml-record\install-record.txt --single-version-externally-managed --compile&quot; failed with error code 1 in C:\Users\ASUS\AppData\Local\Temp\pip-build-qkm97m8f\Twisted\ 可以看到是安装Twisted出的问题，解决方法是在 这里 下载对应版本的whl包，我的是Twisted-17.9.0-cp36-cp36m-win32.whl，cp后面是Python版本，win32表示位数，我的Python是32位的。 然后切换到下载目录运行以下命令：1pip install Twisted-17.9.0-cp36-cp36m-win32.whl 然后再安装Scrapy就可以了。你会看到：1Successfully installed PyDispatcher-2.0.5 asn1crypto-0.24.0 cffi-1.11.4 cryptography-2.1.4 cssselect-1.0.3 parsel-1.4.0 pyOpenSSL-17.5.0 pyasn1-0.4.2 pyasn1-modules-0.2.1 pycparser-2.18 queuelib-1.4.2 scrapy-1.5.0 service-identity-17.0.0 创建项目切换到你想放这个项目的目录，执行scrapy startproject projectname创建一个项目，如：1scrapy startproject scrapy_test 生成的项目结构是这样的：12345678910scrapy_test/ scrapy.cfg # deploy configuration file scrapy_test/ # project&apos;s Python module, you&apos;ll import your code from here __init__.py items.py # project items definition file middlewares.py # project middlewares file pipelines.py # project pipelines file settings.py # project settings file spiders/ # a directory where you&apos;ll later put your spiders __init__.py spiders目录用于放置我们的爬虫，items.py用于定义我们要获取的数据，pipelines.py定义存储，settings.py顾名思义就是配置文件了。 编写代码 第一步我们先定义要存储什么字段，这里就定义书名、作者和索引号吧，编写items.py：1234567891011import scrapyclass BooksItem(scrapy.Item): &apos;&apos;&apos;定义要存储的字段&apos;&apos;&apos; # 书名 name = scrapy.Field() # 作者 author = scrapy.Field() # 索引号 call_number = scrapy.Field() 接下来我们在spiders目录下编写爬虫文件，我这里新建一个books_spider.py文件，代码如下：1234567891011121314151617181920212223import scrapyfrom scrapy_test.items import BooksItemclass BooksSpider(scrapy.Spider): &apos;&apos;&apos;图书爬虫类&apos;&apos;&apos; # 这个name不能重复 name = &apos;books&apos; # allowed_domains = [&apos;202.116.174.108:8080&apos;] start_urls = [&quot;http://202.116.174.108:8080/top/top_lend.php?cls_no=ALL&quot;] def parse(self, response): &apos;&apos;&apos;处理下载的response的默认方法&apos;&apos;&apos; books = [] for item in response.xpath(&apos;//tr&apos;)[1:]: book = BooksItem() book_name = item.xpath(&apos;td[2]/a/text()&apos;).extract() book_author = item.xpath(&apos;td[3]/text()&apos;).extract() book_call_number = item.xpath(&apos;td[5]/text()&apos;).extract() book[&apos;name&apos;] = book_name[0] book[&apos;author&apos;] = book_author[0] book[&apos;call_number&apos;] = book_call_number[0] books.append(book) return books 这个类继承scrapy.Spider，需要指定name，它是运行爬虫用的，start_urls是要爬取的url列表，parse函数接收获取到的response解析用的是scrapy自带的xpath,这个网页的结构很简单，所以就不多解释了。总之，就是遍历每一本书的信息，然后存在books中。这些信息在之前的item中已经定义了。代码的编写到这里就结束了，接下来就可以运行了。 运行代码要运行代码，切换到项目的目录里，执行下面的命令，其中books就是上面的name，books.json就是生成的json文件：1scrapy crawl books -o books.json -t json 开始运行时，出现了一个问题，就是没报错，但没有结果，输出一片空白，然后发现下面的提示：1DEBUG: Forbidden by robots.txt 这是因为要获取的页面在robots中被禁止了，所以Scrapy自动忽略了，只需修改settings.py将：ROBOTSTXT_OBEY改为False就行了。 后来又遇到了乱码的问题，输出全是\uxxx这种字符，只要在settings.py加上FEED_EXPORT_ENCODING = &#39;utf-8&#39;就可以。 没报错执行完上面的命令之后就会在根目录生成一个books.json文件，打开，就会看到保存下来的json格式图书信息：123456789101112131415161718192021222324[ &#123; &quot;name&quot;: &quot;暗恋·橘生淮南&quot;, &quot;author&quot;: &quot;八月长安[著]&quot;, &quot;call_number&quot;: &quot;I247.57/5494&quot; &#125;, &#123; &quot;name&quot;: &quot;Time series and panel data econometrics / First edition.&quot;, &quot;author&quot;: &quot;M. Hashem Pesaran.&quot;, &quot;call_number&quot;: &quot;F224.0/EN4&quot; &#125;, &#123; &quot;name&quot;: &quot;杀死一只知更鸟.第2版&quot;, &quot;author&quot;: &quot;(美国) 哈珀·李著&quot;, &quot;call_number&quot;: &quot;I712.45/1231=2&quot; &#125;, ... ... &#123; &quot;name&quot;: &quot;众筹:互联网金融的下一个风口&quot;, &quot;author&quot;: &quot;陈晓暾, 白帆, 陈英编著&quot;, &quot;call_number&quot;: &quot;F830.45/77&quot; &#125;] 我们的Scrapy入门项目就完成了！]]></content>
      <categories>
        <category>Python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Scrapy</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo搭建个人博客]]></title>
    <url>%2FHexo%2FHexo%2BGitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[其实网上已经有很多这样的教程了，我这里只是把自己一步步搭建的过程做一些记录而已。闲话不多说，马上开始。 准备环境 Git，先 点击这里 下载Git安装，安装过程我就不作说明了 Node.js，点击这里 下载安装，安装也很简单方便，这里也不作说明，记得安装上npm就好 GitHub账号当然不能少，这里就默认你已经有账号了…没有的 点击这里 去注册吧 Hexo安装与搭建首先，新建一个文件夹，你的博客就要放在这里，我这里是E:\hexo，然后，在这个文件夹里右键Git Bash Here，因为要使用到这个，所以就不用cmd命令行直接用这个了。执行以下命令安装Hexo：1npm install -g hexo-cli 再执行以下命令，生成建立网站所需要的所有文件并安装依赖包：12hexo initnpm install 然后，我们在根目录下的_config.yml文件，填上自己博客的相应信息，注意，冒号后面都要有一个空格，这是yml文件的格式：123456title: # 标题subtitle: # 副标题description: # 站点描述author: # 作者language: zh-Hanstimezone: 然后，以下命令生成静态页面并开启本地服务器12hexo generatehexo server 现在，浏览器输入http://localhost:4000就能查看你的博客了，当然，只是本地，接下来，就是放到GitHub上让别人能访问了。 部署到GitHub创建仓库首先New Repository，名称是username.github.io，username要与账号对应，比如我的就是JianFengY.github.io，所以，我的GitHub账号本来应该全部小写字母的，这样会比较协调… 生成SSH密钥执行以下命令，不出意外应该是一直回车就好。1ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 然后，在C:\Users\ASUS\.ssh目录会有两个文件id_rsa和id_rsa.pub,打开id_rsa.pub，复制里面的所有内容到 SSH keys这里 的Key，Title随便填，然后Add SSH key就可以了 部署首先，在根目录下的_config.yml文件，找到deploy，填上相应信息，repo就是上面创建的仓库地址：1234deploy: type: git repo: https://github.com/username/username.github.io.git branch: master 安装hexo-deployer-git部署发布工具:1npm install hexo-deployer-git --save 然后就可以使用以下命令发布你的博客了，第一次发布会让你输入Github 的邮箱和密码：1hexo generate &amp;&amp; hexo deploy 这里贴一下Hexo常用命令：1234567hexo init # 初始化目录hexo server 或 hexo s # 本地服务器预览hexo new &quot;postName&quot; 或 hexo n &quot;postName&quot; # 新建文章hexo new page &quot;pageName&quot; 或 hexo n &quot;pageName&quot; # 新建页面hexo generate 或 hexo g # 生成网页在 public 目录有整个网站的文件hexo deploy 或 hexo d # 部署.deploy目录hexo clean # 清除缓存 完成现在，浏览器输入https://username.github.io/我的就是https://jianfengy.github.io/就能查看你的博客了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu配置JDK、MySQL和Tomcat遇到的一些坑]]></title>
    <url>%2FUbuntu%2FUbuntu%E9%85%8D%E7%BD%AEJDK%E3%80%81MySQL%E5%92%8CTomcat%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[之前买了阿里云的Ubuntu服务器，安装JDK、MySQL和Tomcat的时候遇到了一些问题，折腾了挺长时间，这里是一些记录。 安装配置JDKwindows上下载的jdk-8u161-linux-i586.tar.gz用xshell执行rz命令上传到阿里云的ubuntu，然后执行mkdir /usr/java建一个文件夹，再执行tar zxvf jdk-8u161-linux-i586.tar.gz -C /usr/java解压到java目录下，之后执行vim ~/.bashrc在文件尾添加以下内容设置环境变量：1234export JAVA_HOME=/usr/java/jdk1.8.0_151export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:&#123;JAVA_HOME&#125;/lib:&#123;JRE_HOME&#125;/libexport PATH=&#123;JAVA_HOME&#125;/bin:PATH 这里遇到了报错-bash: java/ jdk1.8.0_131/bin/java: cannot execute binary file，是因为我下载的JDK是64位的，而ubuntu是32位的…使用getconf LONG_BIT命令可以查看linux位数。 安装配置Mysql安装时有遇到Err http://mirrors.aliyun.com/ubuntu 404 Not Found，执行sudo apt-get update就可以了。 网上学到的一个技巧：如果忘记了MySQL账户的密码，文件/etc/mysql/debian.cnf里有个MySQL用户debian-sys-maint。可以mysql -u debian-sys-maint -p使用文件提供的密码登录MySQL修改root的密码。 修改MySQL密码时因为设置的密码过于简单会报错Your password does not satisfy the current policy requirements，处理如下：123456789101112mysql&gt; update mysql.user set authentication_string=password(&apos;123456&apos;) where user=&apos;root&apos; and Host =&apos;localhost&apos;;ERROR 1819 (HY000): Your password does not satisfy the current policy requirementsmysql&gt; set global validate_password_policy=0;Query OK, 0 rows affected (0.00 sec)mysql&gt; set global validate_password_length=4;Query OK, 0 rows affected (0.00 sec)mysql&gt; update mysql.user set authentication_string=password(&apos;123456&apos;) where user=&apos;root&apos; and Host =&apos;localhost&apos;;Query OK, 1 row affected, 1 warning (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 1 安装配置tomcat安装运行之后不能使用外网访问，执行ufw allow 8080允许外网可以访问8080端口然后配置阿里云安全组，找到自己的实例，点击更多-安全组配置-配置规则-添加安全组规则配置端口范围8080/8080，授权对象0.0.0.0/0之后就可以了。]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>JDK</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySql学习笔记]]></title>
    <url>%2FMySQL%2FMySql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这是我之前在慕课网学习 与MySQL的零距离接触 时的笔记，整理了一下发上来。 修改MySQL提示符 参数 描述 \p 完整的日期 \d 当前数据库 \h 服务器名称 \u 当前用户 各个参数可以结合使用。如prompt \u@\h \d&gt; 连接客户端时指定 1mysql -uroot -p123456 --prompt \h 连接上客户端后 1PROMPT &quot;提示符&quot; MySQL常用命令 显示当前服务器版本SELECT VERSION(); 显示当前日期时间SELECT NOW(); 显示当前用户SELECT USER(); 可用SHOW WARNINGS;查看警告信息 MySQL语句规范 关键字与函数名称全部大写 数据库名称、表名称、字段名称全部小写 SQL语句必须以分号结尾 操作数据库 “{}”表示必选项， “|”表示或， “[]”表示可选项 创建数据库1CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] charset_name; 例如：1CREATE DATABASE IF NOT EXISTS db_name CHARACTER SET utf8; 查看当前服务器下数据表列表 1SHOW &#123;DATABASES | SCHEMAS&#125; [LIKE &apos;pattern&apos; | WHERE expr]; 修改数据库 1ALTER &#123;DATABASE | SCHEMA&#125; [db_name] [DEFAULT] CHARACTER SET [=] charset_name; 例如：1ALTER DATABASE db_name CHARACTER SET = gbk; 删除数据库1DROP &#123;DATABASE | SCHEMA&#125; [IF EXISTS] db_name; 数据类型 整型 数据类型 字节 TINYINT 1 SMALLINT 2 MEDIUMINT 3 INT 4 BIGINT 8 浮点型 FLOAT[(M,D)] DOUBLE[(M,D)] M是数字总位数，D是小数点后面的位数。 日期时间型 列类型 存储需求 YEAR 1 TIME 3 DATE 3 DATETIME 8 TIMESTAMP 4 字符型 列类型 存储需求 CHAR(M) M个字节，0&lt;=M&lt;=255 VARCHAR(M) L+1个字节，其中L&lt;=M且0&lt;=M&lt;=65535 TINYTEXT L+1个字节，其中L&lt;2^8 TEXT L+2个字节，其中L&lt;2^16 MEDIUMTEXT L+3个字节，其中L&lt;2^24 LONGTEXT L+4个字节，其中L&lt;2^32 ENUM(‘value1’,’value2’,…) 1或2个字节，取决于枚举值的个数(最多65536个值) SET(‘value1’,’value2’,…) 1、2、3、4或8个字节，取决于set成员数目(最多64个成员) 数据表创建数据表1234CREATE TABLE [IF NOT EXISTS] table_name (column_name data_type,...); 例如：12345CREATE TABLE table_name(username VARCHAR(20),age TINYINT UNSIGNED,salary FLOAT(8,2) UNSIGNED); UNSIGNED表示无符号位，即始终为正数。使用SHOW CREATE TABLE table_name;可以查看建表语句 查看数据表1SHOW TABLES [FROM db_name] [LIKE &apos;pattern&apos; | WHERE expr]; 查看数据表结构1SHOW COLUMNS FROM table_name; 或：1DESC table_name; 插入记录1INSERT [INTO] table_name[(col_name,...)] VALUES(val,...); 查找记录1SELECT expr,... FROM table_name; 空值与非空 NULL，字段值可以为空(可以不写，默认可以为空) NOT NULL，字段值禁止为空 自动编号AUTO_INCREMENT ,必须与主键组合使用，默认情况下，起始值为1，每次增量为1，不需要赋值 主键约束PRIMARY KEY ,每张表只能存在一个主键,用于保证记录的唯一性(不能有重复值)，主键自动为NOT NULL 唯一约束UNIQUE KEY ,可以保证记录唯一性，唯一约束的字段可以为空(NULL)，每张表可以存在多个唯一约束 默认约束DEFAULT ,默认值，插入记录时，如果没有明确为字段复制，则自动赋予默认值 外键约束作用：保证数据的一致性、完整性；实现一对一或一对多关系 要求： 父表（子表所参照的表）和子表（具有外键列的表）必须使用相同的存储引擎（InnoDB），且禁止使用临时表 外键列（有FOREIGN KEY关键字的列）和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度可以不同。否则会报错(errorno：150) 外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL会自动创建索引（主键都会自动创建索引）.以网格形式查看索引：SHOW INDEXES FROM db_name\G; 编辑数据表默认存储引擎在安装MySQL的磁盘的Server 5.7\my.ini```文件里，修改为```default-storage-engine12例： CREATE TABLE provinces(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,pname VARCHAR(20) NOT NULL);1234567```CREATE TABLE users(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,username VARCHAR(20) NOT NULL,pid SMALLINT UNSIGNED,FOREIGN KEY (pid) REFERENCES provinces (id)); 外键约束的参照操作 CASCADE：从父表删除或更新且自动删除或更新子表中匹配的行 SET NULL：从父表删除或更新行，并设置子表中的外键列为NULL。如果适用此项，必须保证兹表列没有制定NOT NULL RESTRICT：拒绝对父表的删除或更新操作 NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同 例：123456CREATE TABLE users1(id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,username VARCHAR(10) NOT NULL,pid SMALLINT UNSIGNED,FOREIGN KEY (pid) REFERENCES provinces (id) ON DELETE CASCADE); 表示级联删除，此时删除provinces表中的记录，user1中相关的记录也会被删除，级联更新ON UPDATE CASCADE同理 表级约束与列级约束 对一个数据列建立的约束，称为列级约束。既可以在列定义时声明，也可以在列定义后声明（NOT NULL和DEFAULT约束只有列级约束，其他几种约束则可以有表级也可以有列级约束） 对多个数据列建立的约束，称为表级约束。只能在列定义后声明 修改数据表添加单列1ALTER TABLE table_name ADD [COLUMN] column_name column_definition [FIRST | AFTER column_name; 其中，FIRST指把新列放在最前面，AFTER指把新列放在指定列，不加此参数默认添加到所有列最后面 添加多列1ALTER TABLE table_name ADD [COLUMN] (column_name column_definition, ...); 添加多列时，要加小括号，且不能制定添加的位置 删除列1ALTER TABLE table_name DROP [COLUMN] column_name; 可以同时操作几个语句，用逗号隔开,如：1ALTER TABLE table_name DROP [COLUMN] column_name,DROP [COLUMN] column_name,ADDADD [COLUMN] column_name column_definition; 添加主键约束1ALTER TABLE table_name ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name, ...); 例：1ALTER TABLE users2 ADD CONSTRAINT PK_users2_id PRIMARY KEY (id); 删除主键约束1ALTER TABLE table_name DROP PRIMARY KEY; 添加唯一约束1ALTER TABLE table_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX | KEY] [index_name] [index_type] (index_col_name, ...); 例：1ALTER TABLE users2 ADD UNIQUE (username); 删除唯一约束要删除唯一约束需要先知道约束的名字：1SHOW INDEXES FROM table_name\G; 1ALTER TABLE table_name DROP &#123;INDEX | KEY&#125; index_name; 添加外键约束1ALTER TABLE table_name ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name, ...) reference_difinition; 例：1ALTER TABLE users2 ADD FOREIGN KEY (pid) REFERENCES provinces (id); 删除外键约束删除外键约束也要先知道约束的名字：1SHOW CREATE TABLE table_name; 1ALTER TABLE table_name DROP FOREIGN KEY fk_symbol; 添加/删除默认约束1ALTER TABLE table_name ALTER [COLUMN] col_name &#123;SET DEFAULT literal | DROP DEFAULT&#125;; 例：12ALTER TABLE users2 ALTER age SET DEFAULT 15;ALTER TABLE users2 ALTER age DROP DEFAULT; 修改列定义1ALTER TABLE table_name MODIFY [COLUMN] col_name column_difinition [FIRST | AFTER col_name]; 例：1ALTER TABLE users2 MODIFY id SMALLINT UNSIGNED NOT NULL FIRST; 注意： 由于存储范围不同，数据类型由大类型改为小类型时可能会导致数据丢失 修改列名称1ALTER TABLE table_name CHANGE [COLUMN] old_col_name new_col_name column_difinition [FIRST | AFTER col_name]; 使用CHANGE语句既可以修改列名称也可以修改列定义 修改数据表名1ALTER TABLE table_name RENAME [TO | AS] new_table_name; 或：1RENAME TABLE table_name TO new_table_name [, table_name2 TO new_table_name2] ... ; RENAME TABLE这个语句可以修改多个数据表的名字 例：12ALTER TABLE users2 RENAME users3;RENAME TABLE users3 TO users2,users1 TO users4; 尽量少使用修改数据列或数据表名的命令，因为在创建了索引或使用了视图或存储过程后，表名和列名被引用的情况下，更名可能会导致视图等无法正常工作 操作记录插入记录第一种方式：1INSERT [INTO] table_name [(col_name, ...)] &#123;VALUES | VALUE&#125; (&#123;expr | DEFAULE&#125;,...),(...),...; 插入的值可以写数学表达式也可以写一些函数如md5(&#39;123&#39;)，也可以一次插入多条记录插入时把AUTO_INCREMENT的字段赋值为NULL或DEFAULT都会自动递增 第二种方式：1INSERT [INTO] table_name SET col_name=&#123;expr | DEFAULT&#125;,...; 与第一种方式的区别在于，此方法可以使用子查询(SubQuery)，而且一次只能插入一条记录 第三种方式： 1INSERT [INTO] table_name [(col_name,...)] SELECT ...; 此方法可以将SELECT查询结果插入到指定数据表，见下文子查询 更新记录（单表更新）1UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1=&#123;expr1 | DEFAULT&#125; [, col_name2=&#123;expr2 | DEFAULT&#125;] ... [WHERE where_condition]; 可以一次更新多条记录，不加WHERE会更新所有记录 例：1UPDATE users SET age = age + 10 WHERE id % 2 = 0; 删除记录（单表删除）1DELETE FROM table_name [WHERE where_condition]; 查询记录123456789SELECT select_expr [, select_expr ...][ FROM table_references [WHERE where_condition] [GROUP BY &#123;col_name | position&#125; [ASC | DESC],...] [HAVING where_condition] [ORDER BY &#123;col_name | expr |position&#125; [ASC | DESC],...] [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;]]; 查询表达式select_expr： 每一个表达式表示想要的一列，必须有至少一个 多个列之间以英文逗号分隔 星号(*)表示所有列。table_name.*可以表示命名表的所有列 查询表达式可以使用[AS] alias_name为其赋予别名 别名可用于GROUP BY, ORDER BY或HAVING子句 条件表达式对记录进行过滤，如果没有指定WHERE子句，则显示所有记录。在WHERE表达式中，可以使用MySQL支持的函数或运算符 查询结果分组[GROUP BY {col_name | position} [ASC | DESC],...]，ASC为升序DESC为降序，默认是升序 分组条件[HAVING where_condition],条件中若使用字段，要保证字段出现在select_expr中，或者使用聚合函数，如count()等 对查询结果进行排序[ORDER BY {col_name | expr |position} [ASC | DESC],...]，position指字段在select_expr中出现的位置，推荐尽量直接指定字段名 限制查询结果返回的数量1[LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;] 例：SELECT * FROM users LIMIT 3,2;表示从第四条开始（编号从0开始，且顺序是查询结果的顺序，受ORDER BY等影响），返回共两条数据 子查询子查询(SubQuery) 是指出现在其他SQL语句内的SELECT子句如：1SELECT * FROM t1 WHERE col1 = (SELECT col2 FROM t2); 其中 SELECT * FROM t1 称为 Outer Query[外查询](或者Outer Statement) , SELECT col2 FROM t2 称为 SubQuery[子查询]。 子查询是嵌套在外查询内部，也有可能在子查询内部再嵌套子查询。而且子查询必须出现在圆括号之间 子查询可以包含多个关键字或条件，如DISTINCT, GROUP BY, ORDER BY, LIMIT, 函数等 子查询的外层查询可以是SELECT, INSERT, UPDATE, SET或DO 子查询的返回值可以是标量、一行、一列或子查询使用比较运算符的子查询比较运算符：=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, !=, &lt;=&gt; 语法结构：operand comparison_operator [ANY | SOME | ALL] subquery 例：1SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &gt; (SELECT ROUND(AVG(goods_price),2) AS avg_price FROM tdb_goods) ORDER BY goods_price DESC; AVG(), MAX(), MIN(), COUNT(), SUM()等为聚合函数，聚合函数只有一个返回值使用比较运算符时，如果子查询返回值多于一行记录可能会报错，这时需要用ANY, SOME或ALL修饰： ANY SOME ALL &gt;, &gt;= 最小值 最小值 最大值 &lt;, &lt;= 最大值 最大值 最小值 = 任意值 任意值 &lt;&gt;, != 任意值 例：1SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price = ANY(SELECT goods_price FROM tdb_goods WHERE goods_cate = &apos;超级本&apos;) ORDER BY goods_price DESC; 使用[NOT] IN 的子查询语法结构：operand comparison_operator [NOT] IN (subquery) 注意： =ANY和=SOME运算符与IN等效；!=ALL或&lt;&gt;ALL运算符与NOT IN等效 使用[NOT] EXISTS的子查询如果子查询返回任何行，EXISTS将返回TRUE，否则返回FALSE 使用INSERT...SELECT插入记录例：1INSERT tdb_goods_cates (cate_name) SELECT goods_cate FROM tdb_goods GROUP BY goods_cate; 多表更新1UPDATE table_references SET col_name1=&#123;expr1 |DEFAULT&#125; [, col_name2=&#123;expr2 | DEFAULT&#125;]... [WHERE where_condition]; 多表更新时可能会出现字段名混淆，这时候一般会使用AS给表起别名，如： 1UPDATE tdb_goods AS g INNER JOIN tdb_goods_brands AS b ON g.brand_name = b.brand_name SET g.brand_name = b.brand_id; 创建表同时插入记录CREATE...SELECT1CREATE TABLE [IF NOT EXISTS] table_name [&#123;create_definition,...)] select_statement; 例：1234CREATE TABLE tdb_goods_brands (brand_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,brand_name VARCHAR(40) NOT NULL) SELECT brand_name FROM tdb_goods GROUP BY brand_name; 连接MySQL在SELECT语句、多表更新、多表删除语句中支持JOIN操作 连接类型： INNER JOIN内连接。MySQL中，JOIN, CROSS JOIN和INNER JOIN是等价的 LEFT [OUTER] JOIN左外连接 RIGHT [OUTER] JOIN右外连接 连接条件ON或WHERE： 通常使用ON关键字来设定连接条件 使用WHERE关键字进行结果集记录的过滤 语法结构：table_reference {[INNER | CROSS] JOIN | {LEFT | RIGHT} [OUTER] JOIN} table_reference ON conditional_expr 数据表参照table_reference1table_name [[AS] alias] | table_subquery [AS] alias 数据表可以使用table_name AS alias_name或table_name alias_name赋予别名 table_subquery可以作为子查询使用在FROM子句中，这样的子查询必须为其赋予别名 内连接显示左表及右表符合连接条件的记录，即两表的公共部分 左外连接显示左表的全部记录及右表符合连接条件的记录 右外连接显示右表的全部记录及左表符合连接条件的记录 多表连接通过内连接实现查询所有商品的详细信息：123SELECT goods_id,goods_name,cate_name,brand_name,goods_price FROM tdb_goods AS gINNER JOIN tdb_goods_cates AS c ON g.cate_id = c.cate_idINNER JOIN tdb_goods_brands AS b ON g.brand_id = b.brand_id\G; 通过左外连接实现查询所有商品的详细信息：123SELECT goods_id,goods_name,cate_name,brand_name,goods_price FROM tdb_goods AS gLEFT JOIN tdb_goods_cates AS c ON g.cate_id = c.cate_idLEFT JOIN tdb_goods_brands AS b ON g.brand_id = b.brand_id\G; 通过右外连接实现查询所有商品的详细信息：123SELECT goods_id,goods_name,cate_name,brand_name,goods_price FROM tdb_goods AS gRIGHT JOIN tdb_goods_cates AS c ON g.cate_id = c.cate_idRIGHT JOIN tdb_goods_brands AS b ON g.brand_id = b.brand_id\G; 一些说明 对于左外连接A LEFT JOIN B join_condition（右外连接类似）： 数据表B的结果集依赖数据表A 数据表A的结果集根据左连接条件以来所有数据表（B表除外） 左外连接条件决定如何检索数据表B（在没有制定WHERE条件的情况下） 如果数据表A的某条记录符合WHERE条件，但是数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外B行 如果使用内连接查找的记录在连接数据表中不存在，并且在WHERE子句中尝试以下操作：col_name IS NULL时，如果col_name被定义为NOT NULL，MySQL将在找到符合连接条件的记录后停止搜索更多的行 无限分类的数据表设计例：12345CREATE TABLE tdb_goods_types(type_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,type_name VARCHAR(20) NOT NULL,parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0); parent_id 就是该类的父类，来自 type_id，没有父类（即最大类）的 type_id为0 这种数据表的查询用到自身连接（同一个数据表对其自身进行连接）如： 查找所有分类及其父类： 1SELECT s.type_id,s.type_name,p.type_name FROM tdb_goods_types AS s LEFT JOIN tdb_goods_types AS p ON s.parent_id = p.type_id; 查找所有分类及其子类： 1SELECT p.type_id,p.type_name,s.type_name FROM tdb_goods_types AS p LEFT JOIN tdb_goods_types AS s ON s.parent_id = p.type_id; 查找所有分类及其子类的数目 1SELECT p.type_id,p.type_name,count(s.type_name) AS children_count FROM tdb_goods_types AS p LEFT JOIN tdb_goods_types AS s ON s.parent_id = p.type_id GROUP BY p.type_name ORDER BY p.type_id; 多表删除1DELETE table_name[.*] [, table_name[.*]] ... FROM table_references [WHERE where_condition]; 例如删除重复记录：1DELETE t1 FROM tdb_goods AS t1 LEFT JOIN (SELECT goods_id,goods_name FROM tdb_goods GROUP BY goods_name HAVING count(goods_name) &gt;= 2 ) AS t2 ON t1.goods_name = t2.goods_name WHERE t1.goods_id &gt; t2.goods_id; 字符函数 函数名称 描述 CONCAT() 字符连接 CONCAT_WS() 使用指定的分隔符进行字符连接 FORMAT() 数字格式化,此函数返回值是字符型 LOWER() 转换成小写字母 UPPER() 转换成大写字母 LEFT() 获取左侧字符 RIGHT() 获取右侧字符 LENGTH() 获取字符串长度（包括空格） LTRIM() 删除字符串的前导空格 RTRIM() 删除字符串的后续空格 TRIM() 删除前导和后续空格 SUBSTRING() 字符串截取 [NOT] LIKE 模式匹配 REPLACE() 字符串替换 注意：表示字符位置的数字是从1开始而不是从0开始的，起始位置的数值可以是负值，表示从后往前数例： SELECT CONCAT_WS(&#39;|&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;);结果：A|B|C SELECT FORMAT(12560.75, 1);结果：12,560.8 SELECT LOWER(LEFT(&#39;MySQL&#39;, 2));结果：my。表示把截取的前两位字符变为小写 SELECT TRIM(LEADING &#39;?&#39; FROM &#39;??My??SQL???&#39;);结果：My??SQL???。这里的LEADING表示删除前导的指定字符，TRAILING表示删除后续，BOTH表示前导和后续都删除 SELECT REPLACE(&#39;??My??SQL???&#39;, &#39;?&#39;, &#39;&#39;);结果：MySQL SELECT SUBSTRING(&#39;MySQL&#39;, 1, 2);结果：My。这里表示从第一位截取，截取两位 SELECT &#39;MYSQL&#39; LIKE &#39;M%&#39;;结果：1。1表示TRUE，%表示任意0个或多个字符，另外还有_下划线表示任意一个字符 假设数据表test有个first_name为tom%的数据，要查找出此记录，就要SELECT * FROM test WHERE first_name LIKE &#39;%1%%&#39; ESCAPE &#39;1&#39;;，表示1后面的%为普通字符串而非通配符 数值运算符与函数 名称 描述 CEIL() 进一取整（向上取整） DIV 整除，如3 DIV 4为0 FLOOR() 舍一取整（向下取整） MOD 取余数（取模，与%相同） POWER() 幂运算 ROUND() 四舍五入 TRUNCATE() 数字截取 例： SELECT POWER(2,3); 结果：8 SELECT TRUNCATE(125.59,1);结果：125.5。保留小数点后一位，舍去后面的，与四舍五入不同 比较运算符与函数 名称 描述 [NOT] BETWEEN…AND… [不]在范围之内 [NOT] IN() [不]在列出值范围内 IS [NOT] NULL [不]为空 例： SELECT 35 BETWEEN 1 AND 35;结果：1 SELECT 13 NOT IN(5, 10, 15);结果：1 SELECT 0 IS NOT NULL;结果：1 日期时间函数 名称 描述 NOW() 当前日期和时间 CURDATE() 当前日期 CURTIME() 当前时间 DATE_ADD() 日期变化 DATEDIFF() 日期差值 DATE_FORMAT() 日期格式化 例 ： SELECT DATE_ADD(&#39;2017-11-23&#39;, INTERVAL -365 DAY);结果：2016-11-23 SELECT DATE_ADD(&#39;2017-11-23&#39;, INTERVAL 3 WEEK);结果：2017-12-14 SELECT DATEDIFF(&#39;2017-11-23&#39;, &#39;2018-11-23&#39;);结果：-365 SELECT DATE_FORMAT(&#39;2017-11-23&#39;, &#39;%m/%d/%Y&#39;);结果：11/23/2017 信息函数 名称 描述 CONNECTION_ID() 连接ID DATABASE() 当前数据库 LAST_INSERT_ID() 最后插入的记录的ID号 USER() 当前用户 VERSION() 版本信息 对于LAST_INSERT_ID()函数，需要数据表里有一个AUTO_INCREMENT的id字段。另外，若是同时插入多条记录，如INSERT test(name,age) VALUES(&#39;Tom&#39;,20),(&#39;Jack&#39;,22);，这个函数只会返回第一个插入的也就是Tom的id 聚合函数 名称 描述 AVG() 平均值 COUNT() 计数 MAX() 最大值 MIN() 最小值 SUM() 求和 聚合函数的典型特点：只有一个返回值 信息函数 名称 描述 MD5() 信息摘要算法 PASSWORD() 密码算法 如果密码是为WEB页面准备的，建议使用MD5(),而PASSWORD()主要用于修改MySQL的用户密码 自定义函数 用户自定义函数(user-defined function, UDF)是一种对MySQL扩展的途径，其用法与内置函数相同 两个必要条件：参数（可以有0个或多个）、返回值（只能有一个） 函数可以返回任意类型的值，同样可以接收这些类型的参数；参数与返回值之间没有必然的内在联系 创建自定义函数1CREATE FUNCTION function_name RETURNS &#123;STRING | INTEGER | REAL | DECIMAL&#125; routine_body; 删除自定义函数用DROP FUNCTION [IF EXISTS] function_name; 关于函数体routine_body： 函数体由合法的SQL语句构成 函数体可以是简单的SELECT或INSERT语句 函数体如果为复合结构则使用BEGIN...END语句 复合结构可以包含声明、循环、控制结构 例：12CREATE FUNCTION f1() RETURNS VARCHAR(30)RETURN DATE_FORMAT(NOW(),&apos;%Y年%m月%d日 %H点:%i分:%s秒&apos;); 123CREATE FUNCTION f2(num1 SMALLINT UNSIGNED, num2 SMALLINT UNSIGNED)RETURNS FLOAT(10,2) UNSIGNEDRETURN (num1+num2)/2; 有时候需要创建有复合结构函数体的自定义函数，由于分隔符;被认为是SQL语句的结束，所以要先执行DELIMITER //修改SQL语句的结束符1234567CREATE FUNCTION adduser(username VARCHAR(20))RETURNS INT UNSIGNEDBEGININSERT test(username) VALUES (username);RETURN LAST_INSERT_ID();END// 之后就可以把分隔符修改回来和使用函数了：12DELIMITER ;SELECT adduser(&apos;Rose&apos;); 存储过程 存储过程是SQL语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理 存储过程存储在数据库内，可以由应用程序调用执行，允许用户声明变量以及进行流程控制 存储过程可以接收输入和输出类型的参数且可以存在多个返回值 存储过程只在第一次进行语法分析和编译，以后都直接调用编译结果，省略了编译环节 优点： 增强SQL语句的功能和灵活性 实现较快的执行速度 减少网络流量 创建存储过程12345CREATE[DEFINER = &#123;user | CURRENT_USER&#125;]PROCEDURE sp_name ([proc_parameter[,...]])[characteristic ...]routine_body DEFINER是创建者，省略的话默认是当前登录到MySQL的用户 sp_name是存储过程的名字 proc_parameter是参数，可以有0到多个，写法：[IN | OUT | INOUT]param_name type。注意： 参数名不要和数据表字段名重名 IN，表示该参数的值必须在调用存储过程时指定，该值不能被返回 OUT，表示该参数的值可以被存储过程改变，并且可以被返回 INOUT，表示该参数的值在调用时指定，并且可以被改变和返回 characteristic特性，与自定义函数相似： COMMENT：注释 CONTAINS SQL：包含SQL语句，但不包含读或写数据的语句 NO SQL：不包含SQL语句 READS SQL DATA：包含读数据的语句 MODIFIES SQL DATA：包含写数据的语句 SQL SECURITY {DEFINER | INVOKER}：指明谁有权限来执行1COMMENT &apos;string&apos; | &#123;CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA&#125; | SQL SECURITY &#123;DEFINER | INVOKER&#125; routine_body过程体： 过程体由合法的SQL语句构成 过程体可以是任意SQL语句（主要指对记录的增删改查及多表连接等而非对数据库数据表本身的修改） 过程体如果为复合结构则使用BEGIN...END语句 复合结构可以包含声明、循环、控制结构 调用存储过程12CALL sp_name([parameter[,...]]);CALL sp_name[()]; 修改存储过程和修改自定义函数相似，只能修改以下简单的选项，不能修改过程体，要修改过程体只能删除该存储过程然后重新创建1ALTER PROCEDURE sp_name [characteristic ...] COMMENT &apos;string&apos; | &#123;CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA&#125; | SQL SECURITY &#123;DEFINER | INVOKER&#125;; 删除存储过程删除时不用带参数，只用存储过程名称1DROP PROCEDURE [IF EXISTS] sp_name; 创建不带参数的存储过程例：1CREATE PROCEDURE sp1() SELECT VERSION(); 调用：因为不带参数，所以CALL sp1;或CALL sp1();都可以 创建带有IN类型参数的存储过程和创建自定义函数一样要先使用DELIMITER //修改结束符123456789DELIMITER //CREATE PROCEDURE removeUserById(IN p_id INT UNSIGNED)BEGINDELETE FROM test WHERE id = p_id;END//DELIMITER ; 创建带有IN和OUT类型参数的存储过程12345678910DELIMITER //CREATE PROCEDURE removeUserAndReturnUserCount(IN p_id INT UNSIGNED,OUT userCount INT UNSIGNED)BEGINDELETE FROM test WHERE id = p_id;SELECT count(id) FROM test INTO userCount;END//DELIMITER ; 调用：12CALL removeUserAndReturnUserCount(37,@nums);SELECT @nums; 其中，@nums是变量，在BEGIN...END间用DECLEAR声明的变量叫局部变量，作用域只在BEGIN...END之间。而且在BEGIN...END间DECLEAR语句必须位于第一行。而像上面SELECT...INTO para_name或SET @para_name = ...声明的变量叫用户变量，对当前用户使用的客户端有效 创建带有多个OUT类型参数的存储过程ROW_COUNT() 函数可以得到被影响（即插入、删除或更新）的记录数1234567891011DELIMITER //CREATE PROCEDURE removeUserByAgeAndReturnInfos(IN p_age SMALLINT UNSIGNED, OUT deleteUsers SMALLINT UNSIGNED, OUT userCounts SMALLINT UNSIGNED)BEGINDELETE FROM test WHERE age = p_age;SELECT ROW_COUNT() INTO deleteUsers;SELECT COUNT(id) FROM test INTO userCounts;END//DELIMITER ; 调用：12CALL removeUserByAgeAndReturnInfos(20,@a,@b);SELECT @a,@b; 存储过程与自定义函数的区别 存储过程实现的功能要复杂一些；而函数的针对性更强（针对表做操作一般使用存储过程） 存储过程可以返回多个值；函数只能有一个返回值 存储过程一般独立来执行；而函数可以作为其他SQL语句的组成部分来出现 二者注意事项： 创建存储过程或者自定义函数时需要通过delimiter语句修改定界符 如果函数体或过程体有多个语句，需要包含在BEGIN...END语句块中 存储引擎MySQL可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。每一种存储引擎使用不同的存储机制、索引技巧、锁定水平，最终提供广泛且不同的功能 分类： MyISAM InnoDB Memory Archive CSV（不支持索引） BlackHole：黑洞引擎，写入的数据都会消失，一般用于做数据复制的中继 并发控制当多个连接对记录进行修改时要保证数据的一致性和完整性，就要使用并发控制。处理并发读或并发写时系统会使用锁系统： 共享锁（读锁）：在同一时间段内，多个用户可以读取同一个资源，读取过程中数据不会发生任何变化 排它锁（写锁）：在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其他的读锁或者写锁操作 锁颗粒： 表锁，是一种开销最小的锁策略 行锁，是一种开销最大的锁策略 事务处理事务用于保证数据库的完整性 事务的特性： 原子性(Atomicity) 一致性(Consistency) 隔离性(Isolation) 持久性(Durability) 外键和索引外键是保证数据一致性的策略；索引是对数据表中一列或多列的值进行排序的一种结构，包括：普通索引、唯一索引、全文索引、btree索引、hash索引…… 各种存储引擎的特点 特点 MyISAM InnoDB Memory Archive 存储限制 256TB 64TB 有 无 事务安全 - 支持 - - 支持索引 支持 支持 支持 - 锁颗粒 表锁 行锁 表锁 行锁 数据压缩 支持 - - 支持 支持外键 - 支持 - - 使用得比较多的是MyISAM和InnoDB。MyISAM适用于事务的处理不多的情况；InnoDB适用于事务处理较多，需要有外键支持的情况 修改存储引擎 通过修改MySQL配置文件实现：default-storage-engine= engine_name，默认是InnoDB 通过创建数据表或修改数据表命令实现：1234CREATE TABLE table_name(......)ENGINE = engine_name; 1ALTER TABLE table_name ENGINE [=] engine_name;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
